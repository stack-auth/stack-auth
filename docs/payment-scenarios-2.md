# Payments Scenario Matrix

The table below summarizes how the payments API responds across representative customer histories and purchase actions. Each cell captures the state transitions we enforce in code and the resulting billing or inventory effects.

| Customer starting point \\ Action | Purchases a $20 monthly subscription product that grants one non-expiring item | Switches tiers inside the same catalog (upgrade/downgrade) | Buys a stackable one-time pack that issues expiring items | Receives a test-mode purchase or server-side grant |
| --- | --- | --- | --- | --- |
| **New user with no purchases and no include-by-default products** | Creating a purchase URL provisions a Stripe customer keyed by our metadata before issuing the dashboard purchase code; when they confirm the monthly price, we create a Stripe subscription and revoke the code, so the user is billed $20/month and the included item lands in their ledger without expiration. 【F:apps/backend/src/app/api/latest/payments/purchases/create-purchase-url/route.ts†L38-L95】【F:apps/backend/src/app/api/latest/payments/purchases/purchase-session/route.tsx†L29-L168】【F:apps/backend/src/lib/payments.tsx†L209-L217】【F:apps/e2e/tests/backend/endpoints/api/v1/payments/purchase-session.test.ts†L48-L109】 | Because there are no existing subscriptions, validation finds no conflicts, and the same flow as the first column runs, yielding a fresh subscription in the requested tier. 【F:apps/backend/src/lib/payments.tsx†L458-L505】【F:apps/backend/src/app/api/latest/payments/purchases/purchase-session/route.tsx†L29-L168】 | Validation enforces stackability and quantity rules, then we create a Payment Intent for the one-time pack; upon success the user’s ledger receives the expiring items while respecting repeat/expiry windows. 【F:apps/backend/src/lib/payments.tsx†L434-L505】【F:apps/backend/src/app/api/latest/payments/purchases/purchase-session/route.tsx†L102-L127】【F:apps/backend/src/lib/payments.tsx†L209-L239】【F:apps/e2e/tests/backend/endpoints/api/v1/payments/purchase-session.test.ts†L63-L160】 | Test-mode and server grants reuse the same validation, then synchronously write one-time or subscription rows without Stripe, allowing us to simulate fulfillment for this brand-new user. 【F:apps/backend/src/app/api/latest/internal/payments/test-mode-purchase-session/route.tsx†L1-L52】【F:apps/backend/src/lib/payments.tsx†L564-L641】 |
| **New user where the project ships an include-by-default product** | Default subscriptions are synthesized when we read the catalog, but they do not block paid tiers; purchasing the $20 plan therefore stands up a normal Stripe subscription alongside the implicit default. 【F:apps/backend/src/lib/payments.tsx†L271-L352】【F:apps/backend/src/app/api/latest/payments/purchases/purchase-session/route.tsx†L29-L168】 | Switching tiers in the same catalog cancels or updates any conflicting non-default subscription while leaving the include-by-default record alone, so the user moves cleanly between paid levels. 【F:apps/backend/src/lib/payments.tsx†L493-L505】【F:apps/backend/src/app/api/latest/payments/purchases/purchase-session/route.tsx†L49-L100】 | One-time packs coexist with the default subscription; ledger math stacks the perpetual default grant with the expiring pack quantity so the user gets both entitlements. 【F:apps/backend/src/lib/payments.tsx†L191-L243】 | Grants still respect catalog defaults but otherwise mirror the new-user behavior, inserting the entitlement directly into persistence. 【F:apps/backend/src/lib/payments.tsx†L564-L641】 |
| **Customer already paying for a catalog subscription** | When they attempt to buy the $20 tier, we detect the existing catalog subscription and update or cancel it before creating the new Stripe subscription, ensuring only one active paid tier remains. 【F:apps/backend/src/lib/payments.tsx†L493-L505】【F:apps/backend/src/app/api/latest/payments/purchases/purchase-session/route.tsx†L49-L100】 | Upgrades and downgrades follow the same branch: we either update the existing Stripe item in place (for recurring prices) or cancel it when moving to a one-time plan, then provision the requested tier. 【F:apps/backend/src/app/api/latest/payments/purchases/purchase-session/route.tsx†L49-L127】 | Stackable packs bypass the subscription conflict logic, so the customer can layer additional expiring quantity on top of their active plan; duplicate non-stackable products are still blocked. 【F:apps/backend/src/lib/payments.tsx†L445-L505】【F:apps/backend/src/lib/payments.test.tsx†L915-L940】 | Test-mode grants or admin APIs first cancel conflicting catalog subscriptions in our database, then persist the new grant without touching Stripe, which mirrors how real upgrades behave. 【F:apps/backend/src/lib/payments.tsx†L564-L641】 |
| **Customer with prior one-time purchase in the same catalog** | Validation fails before Stripe is contacted, returning a 400 that the catalog already has a one-time grant, so we never attempt to create the $20 subscription. 【F:apps/backend/src/lib/payments.tsx†L449-L490】【F:apps/backend/src/lib/payments.test.tsx†L815-L915】 | Catalog switches are equally blocked until the existing one-time record is removed, preventing multiple lifetime-style entitlements in the catalog. 【F:apps/backend/src/lib/payments.tsx†L482-L505】【F:apps/backend/src/lib/payments.test.tsx†L849-L915】 | Additional stackable packs are allowed only when the product is marked stackable; otherwise we raise `PRODUCT_ALREADY_GRANTED`, mirroring the duplicate safeguards in tests. 【F:apps/backend/src/lib/payments.tsx†L445-L472】【F:apps/backend/src/lib/payments.test.tsx†L815-L847】 | Test-mode or server grants obey the same guard rails, so attempts to hand out another lifetime pack will be rejected during validation. 【F:apps/backend/src/lib/payments.tsx†L564-L641】 |
| **Customer buying an add-on without the required base product** | The subscription purchase fails fast with a 400 because validation requires at least one owned product listed in `isAddOnTo` before proceeding. 【F:apps/backend/src/lib/payments.tsx†L474-L505】 | Upgrade/downgrade attempts for the add-on follow the same guard, keeping the catalog consistent until the base product exists. 【F:apps/backend/src/lib/payments.tsx†L474-L505】 | One-time add-on packs are likewise rejected unless the base subscription is active, so no ledger entries are created. 【F:apps/backend/src/lib/payments.tsx†L474-L505】 | Grants cannot circumvent the dependency either—the validator runs before we insert records, so the add-on is denied until the prerequisite is present. 【F:apps/backend/src/lib/payments.tsx†L564-L641】 |
| **Customer with manual item adjustments and expiring quantities** | When the user renews the $20 plan, the resulting subscription entries merge with prior manual grants and expirations, and the ledger ensures only unexpired balance is counted. 【F:apps/backend/src/lib/payments.tsx†L160-L243】 | Catalog switches leave the ledger intact—the new subscription’s schedule is layered on top of existing manual adjustments while canceled subscriptions stop contributing once expired. 【F:apps/backend/src/lib/payments.tsx†L191-L243】【F:apps/backend/src/lib/payments.tsx†L534-L562】 | Buying a stackable pack adds more ledger transactions that expire according to the pack’s repeat settings, which combine with manual positives/negatives in the running balance. 【F:apps/backend/src/lib/payments.tsx†L160-L239】【F:apps/backend/src/lib/payments.test.tsx†L786-L810】 | Test-mode grants and API adjustments both write ledger-affecting records (item quantity changes or purchases), so manual corrections and simulated grants accumulate exactly like live traffic. 【F:apps/backend/src/lib/payments.tsx†L160-L243】【F:apps/backend/src/lib/payments.tsx†L564-L641】 |

