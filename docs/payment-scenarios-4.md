# Payments scenario matrix

This document captures how the payments API responds across a broad set of customer histories and purchase actions. Each cell summarizes the observable behavior today based on the production handlers and the accompanying end-to-end tests.

| Scenario | Subscription checkout flow | One-time purchases & quantity rules | Catalog & plan switching | Test mode, API grants, and item effects |
| --- | --- | --- | --- | --- |
| **New user with no owned products and no include-by-default entries** | Creating a purchase URL validates product access, provisions or reuses the Stripe customer, and issues a verification code; completing checkout selects the requested price, creates a Stripe subscription in `default_incomplete` mode, and returns the client secret when no conflicts exist.【F:apps/backend/src/app/api/latest/payments/purchases/create-purchase-url/route.ts†L38-L95】【F:apps/backend/src/app/api/latest/payments/purchases/purchase-session/route.tsx†L29-L168】【F:apps/e2e/tests/backend/endpoints/api/v1/payments/purchase-session.test.ts†L48-L61】 | The same flow resolves to the one-time branch when a non-recurring price is chosen, enforcing stackability rules and creating a Payment Intent that returns a client secret when quantity rules are met.【F:apps/backend/src/lib/payments.tsx†L434-L447】【F:apps/backend/src/app/api/latest/payments/purchases/purchase-session/route.tsx†L102-L127】【F:apps/e2e/tests/backend/endpoints/api/v1/payments/purchase-session.test.ts†L63-L159】 | With no existing grants, catalog checks find no one-time purchases or active subscriptions to block, so the session proceeds without conflict entries.【F:apps/backend/src/lib/payments.tsx†L449-L505】 | Server-side grants and test-mode sessions reuse the same validation and persistence logic, producing subscription or one-time records that mirror live purchases when invoked for a brand-new customer.【F:apps/backend/src/lib/payments.tsx†L564-L639】【F:apps/backend/src/app/api/latest/internal/payments/test-mode-purchase-session/route.tsx†L25-L57】 |
| **New user where catalog config includes an `include-by-default` product** | `getSubscriptions` synthesizes an always-active subscription for each include-by-default product, so listing the customer already surfaces those entitlements even before checkout.【F:apps/backend/src/lib/payments.tsx†L271-L351】 | Included items on default products contribute to ledger calculations the same way as purchased plans, so any immediate usage limits reflect the product's configured quantity and expiry rules.【F:apps/backend/src/lib/payments.tsx†L145-L239】 | Include-by-default subscriptions are ignored when building the conflicting catalog list, allowing the user to upgrade into paid plans in the same catalog without spurious blocks.【F:apps/backend/src/lib/payments.tsx†L493-L505】 | When a test-mode grant or API grant is issued on top of defaults, the shared grant helper simply adds new subscription or purchase rows, and downstream item quantities increase accordingly (for example, bundled credits rise after a test-mode checkout).【F:apps/backend/src/lib/payments.tsx†L564-L639】【F:apps/e2e/tests/backend/endpoints/api/v1/payments/purchase-session.test.ts†L367-L436】 |
| **Customer already owns a non-stackable subscription or one-time product** | Validation rejects another purchase of the same configured product (or one lacking stackability), emitting `PRODUCT_ALREADY_GRANTED` before checkout attempts to change billing.【F:apps/backend/src/lib/payments.tsx†L465-L472】【F:apps/e2e/tests/backend/endpoints/api/v1/payments/purchase-session.test.ts†L769-L837】 | Quantity checks continue to enforce `stackable !== true`, producing a `400` error in both live and test-mode flows when a user requests quantity > 1 for a non-stackable price.【F:apps/backend/src/lib/payments.tsx†L434-L447】【F:apps/e2e/tests/backend/endpoints/api/v1/payments/purchase-session.test.ts†L111-L160】【F:apps/e2e/tests/backend/endpoints/api/v1/payments/purchase-session.test.ts†L240-L280】 | Attempting to move to another plan within the same catalog causes the handler to update the existing Stripe subscription in place or cancel a DB-only record before creating the new one, ensuring a single active catalog membership.【F:apps/backend/src/app/api/latest/payments/purchases/purchase-session/route.tsx†L49-L101】【F:apps/e2e/tests/backend/endpoints/api/v1/payments/purchase-session.test.ts†L561-L767】 | Test-mode grants call the same helper that cancels conflicting records, so moving from a simulated subscription to a live checkout clears the stub subscription first; repeated grants for the same product remain blocked by the shared `PRODUCT_ALREADY_GRANTED` guard.【F:apps/backend/src/lib/payments.tsx†L564-L639】【F:apps/backend/src/app/api/latest/internal/payments/test-mode-purchase-session/route.tsx†L25-L57】【F:apps/e2e/tests/backend/endpoints/api/v1/payments/purchase-session.test.ts†L668-L837】 |
| **Customer previously completed a one-time purchase in this catalog** | Validation refuses another purchase of the same product when it is non-stackable or already owned, surfacing the known error before reaching Stripe.【F:apps/backend/src/lib/payments.tsx†L465-L472】【F:apps/e2e/tests/backend/endpoints/api/v1/payments/purchase-session.test.ts†L769-L837】 | One-time catalog enforcement prevents buying any other one-time offer in that catalog once a `oneTimePurchase` record exists, producing a descriptive `400` response in follow-up checkouts.【F:apps/backend/src/lib/payments.tsx†L482-L505】【F:apps/e2e/tests/backend/endpoints/api/v1/payments/purchase-session.test.ts†L840-L905】 | Because the catalog check runs before conflicts are resolved, the handler never attempts to swap Stripe subscriptions—instead it blocks at validation time when a prior one-time purchase is present.【F:apps/backend/src/lib/payments.tsx†L482-L505】 | Test-mode completions persist one-time purchases to the database, so later live checkouts in the same catalog are rejected by the shared validation path; the helper records creation source but still blocks duplicates.【F:apps/backend/src/lib/payments.tsx†L607-L620】【F:apps/e2e/tests/backend/endpoints/api/v1/payments/purchase-session.test.ts†L769-L905】 |
| **Customer attempting to buy an add-on product** | `validatePurchaseSession` ensures at least one of the referenced base products is already owned before proceeding, otherwise the request fails with a `400` explaining the missing dependency.【F:apps/backend/src/lib/payments.tsx†L474-L477】 | Add-ons still obey stackability rules, so non-stackable add-ons cannot be purchased in multiples, and the absence of base ownership blocks both subscription and one-time purchases.【F:apps/backend/src/lib/payments.tsx†L434-L447】【F:apps/backend/src/lib/payments.tsx†L474-L477】 | Catalog conflict detection excludes subscriptions that correspond to the add-on's required bases, preventing the downgrade logic from canceling the product the add-on depends on.【F:apps/backend/src/lib/payments.tsx†L493-L505】 | Because API grants and test-mode sessions call the shared grant helper, the same dependency check runs there as well, so operators cannot programmatically grant an add-on to customers who lack the base plan.【F:apps/backend/src/lib/payments.tsx†L564-L639】 |
| **Inline or server-only product flows** | The `ensureProductIdOrInlineProduct` helper forbids client-side inline definitions and ensures server-only catalog products are not exposed to client keys, while successful server calls issue checkout URLs that work with inline configurations.【F:apps/backend/src/lib/payments.tsx†L21-L68】【F:apps/e2e/tests/backend/endpoints/api/v1/payments/create-purchase-url.test.ts†L5-L198】【F:apps/e2e/tests/backend/endpoints/api/v1/payments/purchase-session.test.ts†L302-L349】 | Inline products still run through quantity validation during checkout, so the same stackability limits and error messaging apply even without a stored product ID.【F:apps/backend/src/lib/payments.tsx†L434-L447】【F:apps/e2e/tests/backend/endpoints/api/v1/payments/purchase-session.test.ts†L302-L349】 | Inline products default to no catalog association, so catalog conflict logic does not intervene; when a server-only stored product is targeted, the helper blocks client access before validation runs.【F:apps/backend/src/lib/payments.tsx†L49-L68】【F:apps/backend/src/lib/payments.tsx†L36-L43】【F:apps/e2e/tests/backend/endpoints/api/v1/payments/create-purchase-url.test.ts†L172-L200】 | API grants and test-mode purchases reuse the same helper to resolve inline definitions, so operators can seed entitlements with inline payloads while staying subject to all validation rules (customer type, quantity, catalogs).【F:apps/backend/src/lib/payments.tsx†L564-L639】【F:apps/backend/src/app/api/latest/internal/payments/test-mode-purchase-session/route.tsx†L25-L57】 |

