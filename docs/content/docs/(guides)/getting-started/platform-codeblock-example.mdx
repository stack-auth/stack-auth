---
title: "Platform Codeblock Example"
---

# Platform Codeblock Example

Here's how to use the new PlatformCodeblock component:

<PlatformCodeblock
  title="Authentication Setup"
  defaultPlatform="Python"
  defaultFrameworks={{
    "Python": "Django",
    "JavaScript": "Next.js"
  }}
  platforms={{
    "Python": {
      "Django": {
        code: `from django.contrib.auth import authenticate, login
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
import json

@csrf_exempt
def login_view(request):
    if request.method == 'POST':
        data = json.loads(request.body)
        username = data.get('username')
        password = data.get('password')
        
        user = authenticate(request, username=username, password=password)
        if user is not None:
            login(request, user)
            return JsonResponse({'success': True})
        else:
            return JsonResponse({'success': False, 'error': 'Invalid credentials'})
    
    return JsonResponse({'error': 'Method not allowed'}, status=405)`,
        language: "python"
      },
      "FastAPI": {
        code: `from fastapi import FastAPI, HTTPException, Depends
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from pydantic import BaseModel
import jwt

app = FastAPI()
security = HTTPBearer()

class LoginRequest(BaseModel):
    username: str
    password: str

@app.post("/login")
async def login(request: LoginRequest):
    # Validate credentials (implement your logic here)
    if validate_user(request.username, request.password):
        token = create_jwt_token(request.username)
        return {"access_token": token, "token_type": "bearer"}
    else:
        raise HTTPException(status_code=401, detail="Invalid credentials")

def validate_user(username: str, password: str) -> bool:
    # Your user validation logic here
    return True  # Placeholder

def create_jwt_token(username: str) -> str:
    # Your JWT token creation logic here
    return "your-jwt-token"  # Placeholder`,
        language: "python"
      },
      "Flask": {
        code: `from flask import Flask, request, jsonify
from werkzeug.security import check_password_hash
from flask_jwt_extended import JWTManager, create_access_token

app = Flask(__name__)
app.config['JWT_SECRET_KEY'] = 'your-secret-key'
jwt = JWTManager(app)

@app.route('/login', methods=['POST'])
def login():
    data = request.get_json()
    username = data.get('username')
    password = data.get('password')
    
    # Validate user credentials (implement your logic)
    user = get_user_by_username(username)
    if user and check_password_hash(user.password_hash, password):
        access_token = create_access_token(identity=username)
        return jsonify({
            'access_token': access_token,
            'success': True
        })
    
    return jsonify({'success': False, 'error': 'Invalid credentials'}), 401

def get_user_by_username(username):
    # Your user lookup logic here
    pass  # Placeholder`,
        language: "python"
      }
    },
    "JavaScript": {
      "Next.js": {
        code: `import { NextRequest, NextResponse } from 'next/server';
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';

export async function POST(request: NextRequest) {
  try {
    const { username, password } = await request.json();
    
    // Validate user credentials (implement your logic)
    const user = await getUserByUsername(username);
    if (!user) {
      return NextResponse.json(
        { success: false, error: 'Invalid credentials' },
        { status: 401 }
      );
    }
    
    const isValidPassword = await bcrypt.compare(password, user.passwordHash);
    if (!isValidPassword) {
      return NextResponse.json(
        { success: false, error: 'Invalid credentials' },
        { status: 401 }
      );
    }
    
    // Create JWT token
    const token = jwt.sign(
      { userId: user.id, username: user.username },
      process.env.JWT_SECRET!,
      { expiresIn: '24h' }
    );
    
    return NextResponse.json({
      success: true,
      token,
      user: { id: user.id, username: user.username }
    });
  } catch (error) {
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    );
  }
}

async function getUserByUsername(username: string) {
  // Your user lookup logic here
  return null; // Placeholder
}`,
        language: "typescript"
      },
      "Express": {
        code: `const express = require('express');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const app = express();

app.use(express.json());

app.post('/login', async (req, res) => {
  try {
    const { username, password } = req.body;
    
    // Validate user credentials (implement your logic)
    const user = await getUserByUsername(username);
    if (!user) {
      return res.status(401).json({
        success: false,
        error: 'Invalid credentials'
      });
    }
    
    const isValidPassword = await bcrypt.compare(password, user.passwordHash);
    if (!isValidPassword) {
      return res.status(401).json({
        success: false,
        error: 'Invalid credentials'
      });
    }
    
    // Create JWT token
    const token = jwt.sign(
      { userId: user.id, username: user.username },
      process.env.JWT_SECRET,
      { expiresIn: '24h' }
    );
    
    res.json({
      success: true,
      token,
      user: { id: user.id, username: user.username }
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: 'Internal server error'
    });
  }
});

async function getUserByUsername(username) {
  // Your user lookup logic here
  return null; // Placeholder
}

app.listen(3000, () => {
  console.log('Server running on port 3000');
});`,
        language: "javascript"
      },
      "React": {
        code: `import React, { useState } from 'react';
import axios from 'axios';

interface LoginFormProps {
  onLoginSuccess: (token: string, user: any) => void;
}

export function LoginForm({ onLoginSuccess }: LoginFormProps) {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);
    setError('');

    try {
      const response = await axios.post('/api/login', {
        username,
        password
      });

      if (response.data.success) {
        onLoginSuccess(response.data.token, response.data.user);
      } else {
        setError(response.data.error || 'Login failed');
      }
    } catch (err: any) {
      setError(err.response?.data?.error || 'Network error');
    } finally {
      setLoading(false);
    }
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <div>
        <label htmlFor="username" className="block text-sm font-medium">
          Username
        </label>
        <input
          id="username"
          type="text"
          value={username}
          onChange={(e) => setUsername(e.target.value)}
          className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2"
          required
        />
      </div>
      
      <div>
        <label htmlFor="password" className="block text-sm font-medium">
          Password
        </label>
        <input
          id="password"
          type="password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
          className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2"
          required
        />
      </div>

      {error && (
        <div className="text-red-600 text-sm">{error}</div>
      )}

      <button
        type="submit"
        disabled={loading}
        className="w-full bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700 disabled:opacity-50"
      >
        {loading ? 'Logging in...' : 'Login'}
      </button>
    </form>
  );
}`,
        language: "typescript"
      }
    }
  }}
/>


<PlatformCodeblock
  title="Authentication Setup"
  defaultPlatform="Python"
  defaultFrameworks={{
    "Python": "Django",
    "JavaScript": "Next.js"
  }}
  platforms={{
    "Python": {
      "Django": {
        code: `from django.contrib.auth import authenticate, login
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
import json

@csrf_exempt
def login_view(request):
    if request.method == 'POST':
        data = json.loads(request.body)
        username = data.get('username')
        password = data.get('password')
        
        user = authenticate(request, username=username, password=password)
        if user is not None:
            login(request, user)
            return JsonResponse({'success': True})
        else:
            return JsonResponse({'success': False, 'error': 'Invalid credentials'})
    
    return JsonResponse({'error': 'Method not allowed'}, status=405)`,
        language: "python",
        filename: "test.py"
      },
      "FastAPI": {
        code: `from fastapi import FastAPI, HTTPException, Depends
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from pydantic import BaseModel
import jwt

app = FastAPI()
security = HTTPBearer()

class LoginRequest(BaseModel):
    username: str
    password: str

@app.post("/login")
async def login(request: LoginRequest):
    # Validate credentials (implement your logic here)
    if validate_user(request.username, request.password):
        token = create_jwt_token(request.username)
        return {"access_token": token, "token_type": "bearer"}
    else:
        raise HTTPException(status_code=401, detail="Invalid credentials")

def validate_user(username: str, password: str) -> bool:
    # Your user validation logic here
    return True  # Placeholder

def create_jwt_token(username: str) -> str:
    # Your JWT token creation logic here
    return "your-jwt-token"  # Placeholder`,
        language: "python"
      },
      "Flask": {
        code: `from flask import Flask, request, jsonify
from werkzeug.security import check_password_hash
from flask_jwt_extended import JWTManager, create_access_token

app = Flask(__name__)
app.config['JWT_SECRET_KEY'] = 'your-secret-key'
jwt = JWTManager(app)

@app.route('/login', methods=['POST'])
def login():
    data = request.get_json()
    username = data.get('username')
    password = data.get('password')
    
    # Validate user credentials (implement your logic)
    user = get_user_by_username(username)
    if user and check_password_hash(user.password_hash, password):
        access_token = create_access_token(identity=username)
        return jsonify({
            'access_token': access_token,
            'success': True
        })
    
    return jsonify({'success': False, 'error': 'Invalid credentials'}), 401

def get_user_by_username(username):
    # Your user lookup logic here
    pass  # Placeholder`,
        language: "python"
      }
    },
    "JavaScript": {
      "Next.js": {
        code: `import { NextRequest, NextResponse } from 'next/server';
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';

export async function POST(request: NextRequest) {
  try {
    const { username, password } = await request.json();
    
    // Validate user credentials (implement your logic)
    const user = await getUserByUsername(username);
    if (!user) {
      return NextResponse.json(
        { success: false, error: 'Invalid credentials' },
        { status: 401 }
      );
    }
    
    const isValidPassword = await bcrypt.compare(password, user.passwordHash);
    if (!isValidPassword) {
      return NextResponse.json(
        { success: false, error: 'Invalid credentials' },
        { status: 401 }
      );
    }
    
    // Create JWT token
    const token = jwt.sign(
      { userId: user.id, username: user.username },
      process.env.JWT_SECRET!,
      { expiresIn: '24h' }
    );
    
    return NextResponse.json({
      success: true,
      token,
      user: { id: user.id, username: user.username }
    });
  } catch (error) {
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    );
  }
}

async function getUserByUsername(username: string) {
  // Your user lookup logic here
  return null; // Placeholder
}`,
        language: "typescript"
      },
      "Express": {
        code: `const express = require('express');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const app = express();

app.use(express.json());

app.post('/login', async (req, res) => {
  try {
    const { username, password } = req.body;
    
    // Validate user credentials (implement your logic)
    const user = await getUserByUsername(username);
    if (!user) {
      return res.status(401).json({
        success: false,
        error: 'Invalid credentials'
      });
    }
    
    const isValidPassword = await bcrypt.compare(password, user.passwordHash);
    if (!isValidPassword) {
      return res.status(401).json({
        success: false,
        error: 'Invalid credentials'
      });
    }
    
    // Create JWT token
    const token = jwt.sign(
      { userId: user.id, username: user.username },
      process.env.JWT_SECRET,
      { expiresIn: '24h' }
    );
    
    res.json({
      success: true,
      token,
      user: { id: user.id, username: user.username }
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: 'Internal server error'
    });
  }
});

async function getUserByUsername(username) {
  // Your user lookup logic here
  return null; // Placeholder
}

app.listen(3000, () => {
  console.log('Server running on port 3000');
});`,
        language: "javascript"
      },
      "React": {
        code: `import React, { useState } from 'react';
import axios from 'axios';

interface LoginFormProps {
  onLoginSuccess: (token: string, user: any) => void;
}

export function LoginForm({ onLoginSuccess }: LoginFormProps) {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);
    setError('');

    try {
      const response = await axios.post('/api/login', {
        username,
        password
      });

      if (response.data.success) {
        onLoginSuccess(response.data.token, response.data.user);
      } else {
        setError(response.data.error || 'Login failed');
      }
    } catch (err: any) {
      setError(err.response?.data?.error || 'Network error');
    } finally {
      setLoading(false);
    }
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <div>
        <label htmlFor="username" className="block text-sm font-medium">
          Username
        </label>
        <input
          id="username"
          type="text"
          value={username}
          onChange={(e) => setUsername(e.target.value)}
          className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2"
          required
        />
      </div>
      
      <div>
        <label htmlFor="password" className="block text-sm font-medium">
          Password
        </label>
        <input
          id="password"
          type="password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
          className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2"
          required
        />
      </div>

      {error && (
        <div className="text-red-600 text-sm">{error}</div>
      )}

      <button
        type="submit"
        disabled={loading}
        className="w-full bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700 disabled:opacity-50"
      >
        {loading ? 'Logging in...' : 'Login'}
      </button>
    </form>
  );
}`,
        language: "typescript"
      }
    }
  }}
/>

## Usage

The PlatformCodeblock component accepts the following props:

- `platforms`: An object defining the platforms and their frameworks with code examples
- `defaultPlatform`: The platform to show by default
- `defaultFrameworks`: Default framework for each platform
- `title`: Optional title for the code block
- `className`: Additional CSS classes

The component will automatically:
- Show a platform selector on the left side
- Show framework tabs on the right side for the selected platform
- Syntax highlight the code based on the specified language
- Adapt to light/dark theme changes
- Persist selections as users switch between platforms and frameworks
