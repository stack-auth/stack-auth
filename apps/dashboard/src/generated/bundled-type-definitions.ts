// This file is auto-generated by scripts/bundle-type-definitions.ts
// Do not edit manually - changes will be overwritten

export type TypeDefinitionFile = {
  path: string,
  content: string,
};

export const BUNDLED_TYPE_DEFINITIONS: TypeDefinitionFile[] = [
  {
    "path": "api-keys/index.ts",
    "content": "import { TeamApiKeysCrud, UserApiKeysCrud, teamApiKeysCreateInputSchema, userApiKeysCreateInputSchema } from \"@stackframe/stack-shared/dist/interface/crud/project-api-keys\";\nimport { filterUndefined } from \"@stackframe/stack-shared/dist/utils/objects\";\nimport { IfAndOnlyIf, PrettifyType } from \"@stackframe/stack-shared/dist/utils/types\";\nimport type * as yup from \"yup\";\n\nexport type ApiKeyType = \"user\" | \"team\";\n\nexport type ApiKey<Type extends ApiKeyType = ApiKeyType, IsFirstView extends boolean = false> =\n  & {\n      id: string,\n      description: string,\n      expiresAt?: Date,\n      manuallyRevokedAt?: Date | null,\n      createdAt: Date,\n      value: IfAndOnlyIf<IsFirstView, true, string, { lastFour: string }>,\n      update(options: ApiKeyUpdateOptions<Type>): Promise<void>,\n      revoke: () => Promise<void>,\n      isValid: () => boolean,\n      whyInvalid: () => \"manually-revoked\" | \"expired\" | null,\n    }\n  & (\n    | (\"user\" extends Type ? { type: \"user\", userId: string } : never)\n    | (\"team\" extends Type ? { type: \"team\", teamId: string } : never)\n  );\n\nexport type UserApiKeyFirstView = PrettifyType<ApiKey<\"user\", true>>;\nexport type UserApiKey = PrettifyType<ApiKey<\"user\", false>>;\n\nexport type TeamApiKeyFirstView = PrettifyType<ApiKey<\"team\", true>>;\nexport type TeamApiKey = PrettifyType<ApiKey<\"team\", false>>;\n\nexport type ApiKeyCreationOptions<Type extends ApiKeyType = ApiKeyType> =\n  & {\n    description: string,\n    expiresAt: Date | null,\n    /**\n     * Whether the API key should be considered public. A public API key will not be detected by the secret scanner, which\n     * automatically revokes API keys when it detects that they may have been exposed to the public.\n     */\n    isPublic?: boolean,\n  };\nexport function apiKeyCreationOptionsToCrud(type: \"user\", userId: string, options: ApiKeyCreationOptions<\"user\">): Promise<yup.InferType<typeof userApiKeysCreateInputSchema>>;\nexport function apiKeyCreationOptionsToCrud(type: \"team\", teamId: string, options: ApiKeyCreationOptions<\"team\">): Promise<yup.InferType<typeof teamApiKeysCreateInputSchema>>;\nexport function apiKeyCreationOptionsToCrud(type: ApiKeyType, userIdOrTeamId: string, options: ApiKeyCreationOptions): Promise<yup.InferType<typeof userApiKeysCreateInputSchema> | yup.InferType<typeof teamApiKeysCreateInputSchema>>;\nexport async function apiKeyCreationOptionsToCrud(type: ApiKeyType, userIdOrTeamId: string, options: ApiKeyCreationOptions): Promise<yup.InferType<typeof userApiKeysCreateInputSchema> | yup.InferType<typeof teamApiKeysCreateInputSchema>> {\n  return {\n    description: options.description,\n    expires_at_millis: options.expiresAt == null ? options.expiresAt : options.expiresAt.getTime(),\n    is_public: options.isPublic,\n    ...(type === \"user\" ? { user_id: userIdOrTeamId } : { team_id: userIdOrTeamId }),\n  };\n}\n\n\nexport type ApiKeyUpdateOptions<Type extends ApiKeyType = ApiKeyType> = {\n  description?: string,\n  expiresAt?: Date | null,\n  revoked?: boolean,\n};\nexport function apiKeyUpdateOptionsToCrud(type: \"user\", options: ApiKeyUpdateOptions<\"user\">): Promise<UserApiKeysCrud[\"Client\"][\"Update\"]>;\nexport function apiKeyUpdateOptionsToCrud(type: \"team\", options: ApiKeyUpdateOptions<\"team\">): Promise<TeamApiKeysCrud[\"Client\"][\"Update\"]>;\nexport function apiKeyUpdateOptionsToCrud(type: ApiKeyType, options: ApiKeyUpdateOptions): Promise<UserApiKeysCrud[\"Client\"][\"Update\"] | TeamApiKeysCrud[\"Client\"][\"Update\"]>;\nexport async function apiKeyUpdateOptionsToCrud(type: ApiKeyType, options: ApiKeyUpdateOptions): Promise<UserApiKeysCrud[\"Client\"][\"Update\"] | TeamApiKeysCrud[\"Client\"][\"Update\"]> {\n  return filterUndefined({\n    description: options.description,\n    expires_at_millis: options.expiresAt == null ? options.expiresAt : options.expiresAt.getTime(),\n    revoked: options.revoked,\n  });\n}\n"
  },
  {
    "path": "apps/index.ts",
    "content": "export {\n  StackClientApp\n} from \"./interfaces/client-app\";\nexport type {\n  StackClientAppConstructor,\n  StackClientAppConstructorOptions,\n  StackClientAppJson\n} from \"./interfaces/client-app\";\n\nexport {\n  StackServerApp\n} from \"./interfaces/server-app\";\nexport type {\n  StackServerAppConstructor,\n  StackServerAppConstructorOptions\n} from \"./interfaces/server-app\";\n\nexport {\n  StackAdminApp\n} from \"./interfaces/admin-app\";\nexport type {\n  StackAdminAppConstructor,\n  StackAdminAppConstructorOptions\n} from \"./interfaces/admin-app\";\n\n"
  },
  {
    "path": "apps/interfaces/admin-app.ts",
    "content": "import { AnalyticsQueryOptions, AnalyticsQueryResponse } from \"@stackframe/stack-shared/dist/interface/crud/analytics\";\nimport type { AdminGetSessionReplayChunkEventsResponse, AdminGetSessionReplayAllEventsResponse } from \"@stackframe/stack-shared/dist/interface/crud/session-replays\";\nimport type { Transaction, TransactionType } from \"@stackframe/stack-shared/dist/interface/crud/transactions\";\nimport { InternalSession } from \"@stackframe/stack-shared/dist/sessions\";\nimport type { MoneyAmount } from \"@stackframe/stack-shared/dist/utils/currency-constants\";\nimport type { EditableMetadata } from \"@stackframe/stack-shared/dist/utils/jsx-editable-transpiler\";\nimport { Result } from \"@stackframe/stack-shared/dist/utils/results\";\nimport { AsyncStoreProperty, EmailConfig } from \"../../common\";\nimport { AdminEmailOutbox, AdminSentEmail } from \"../../email\";\nimport { InternalApiKey, InternalApiKeyCreateOptions, InternalApiKeyFirstView } from \"../../internal-api-keys\";\nimport { AdminProjectPermission, AdminProjectPermissionDefinition, AdminProjectPermissionDefinitionCreateOptions, AdminProjectPermissionDefinitionUpdateOptions, AdminTeamPermission, AdminTeamPermissionDefinition, AdminTeamPermissionDefinitionCreateOptions, AdminTeamPermissionDefinitionUpdateOptions } from \"../../permissions\";\nimport { AdminProject } from \"../../projects\";\nimport { _StackAdminAppImpl } from \"../implementations\";\nimport { StackServerApp, StackServerAppConstructorOptions } from \"./server-app\";\n\nexport type EmailOutboxListOptions = {\n  status?: string,\n  simpleStatus?: string,\n  limit?: number,\n  cursor?: string,\n};\n\nexport type EmailOutboxListResult = {\n  items: AdminEmailOutbox[],\n  nextCursor: string | null,\n};\n\nexport type EmailOutboxUpdateOptions = {\n  isPaused?: boolean,\n  scheduledAtMillis?: number,\n  cancel?: boolean,\n};\n\nimport type { ListSessionReplayChunksOptions, ListSessionReplayChunksResult, ListSessionReplaysOptions, ListSessionReplaysResult, SessionReplayAllEventsResult } from \"../../session-replays\";\nexport type { AdminSessionReplay, AdminSessionReplayChunk, ListSessionReplaysOptions, ListSessionReplaysResult, ListSessionReplayChunksOptions, ListSessionReplayChunksResult, SessionReplayAllEventsResult } from \"../../session-replays\";\n\n\nexport type StackAdminAppConstructorOptions<HasTokenStore extends boolean, ProjectId extends string> = (\n  & StackServerAppConstructorOptions<HasTokenStore, ProjectId>\n  & {\n    superSecretAdminKey?: string,\n    projectOwnerSession?: InternalSession | (() => Promise<string | null>),\n  }\n);\n\n\nexport type StackAdminApp<HasTokenStore extends boolean = boolean, ProjectId extends string = string> = (\n  & AsyncStoreProperty<\"project\", [], AdminProject, false>\n  & AsyncStoreProperty<\"internalApiKeys\", [], InternalApiKey[], true>\n  & AsyncStoreProperty<\"teamPermissionDefinitions\", [], AdminTeamPermissionDefinition[], true>\n  & AsyncStoreProperty<\"projectPermissionDefinitions\", [], AdminProjectPermissionDefinition[], true>\n  & AsyncStoreProperty<\"emailThemes\", [], { id: string, displayName: string }[], true>\n  & AsyncStoreProperty<\"emailPreview\", [{ themeId?: string | null | false, themeTsxSource?: string, templateId?: string, templateTsxSource?: string }], string, false>\n  & AsyncStoreProperty<\"emailPreviewWithEditableMarkers\", [{ themeId?: string | null | false, themeTsxSource?: string, templateId?: string, templateTsxSource?: string, editableSource?: 'template' | 'theme' | 'both' }], { html: string, editableRegions?: Record<string, unknown> }, false> // THIS_LINE_PLATFORM react-like\n  & AsyncStoreProperty<\"emailTemplates\", [], { id: string, displayName: string, themeId?: string, tsxSource: string }[], true>\n  & AsyncStoreProperty<\"emailDrafts\", [], { id: string, displayName: string, themeId: string | undefined | false, tsxSource: string, sentAt: Date | null }[], true>\n  & AsyncStoreProperty<\"stripeAccountInfo\", [], { account_id: string, charges_enabled: boolean, details_submitted: boolean, payouts_enabled: boolean } | null, false>\n  & AsyncStoreProperty<\n    \"transactions\",\n    [{\n      cursor?: string,\n      limit?: number,\n      type?: TransactionType,\n      customerType?: 'user' | 'team' | 'custom',\n    }],\n    { transactions: Transaction[], nextCursor: string | null },\n    true\n  >\n  & {\n    createInternalApiKey(options: InternalApiKeyCreateOptions): Promise<InternalApiKeyFirstView>,\n\n    createTeamPermissionDefinition(data: AdminTeamPermissionDefinitionCreateOptions): Promise<AdminTeamPermission>,\n    updateTeamPermissionDefinition(permissionId: string, data: AdminTeamPermissionDefinitionUpdateOptions): Promise<void>,\n    deleteTeamPermissionDefinition(permissionId: string): Promise<void>,\n\n    createProjectPermissionDefinition(data: AdminProjectPermissionDefinitionCreateOptions): Promise<AdminProjectPermission>,\n    updateProjectPermissionDefinition(permissionId: string, data: AdminProjectPermissionDefinitionUpdateOptions): Promise<void>,\n    deleteProjectPermissionDefinition(permissionId: string): Promise<void>,\n\n    useSvixToken(): { token: string, url: string | undefined }, // THIS_LINE_PLATFORM react-like\n\n    sendTestEmail(options: {\n      recipientEmail: string,\n      emailConfig: EmailConfig,\n    }): Promise<Result<undefined, { errorMessage: string }>>,\n\n    sendTestWebhook(options: { endpointId: string }): Promise<Result<undefined, { errorMessage: string }>>,\n\n    sendSignInInvitationEmail(email: string, callbackUrl: string): Promise<void>,\n\n    listSentEmails(): Promise<AdminSentEmail[]>,\n\n    useEmailTheme(id: string): { displayName: string, tsxSource: string }, // THIS_LINE_PLATFORM react-like\n    createEmailTheme(displayName: string): Promise<{ id: string }>,\n    updateEmailTheme(id: string, tsxSource: string): Promise<void>,\n    deleteEmailTheme(id: string): Promise<void>,\n    saveChatMessage(threadId: string, message: any): Promise<void>,\n    listChatMessages(threadId: string): Promise<{ messages: Array<any> }>,\n    applyWysiwygEdit(options: {\n      sourceType: \"template\" | \"theme\" | \"draft\",\n      sourceCode: string,\n      oldText: string,\n      newText: string,\n      metadata: EditableMetadata,\n      domPath: Array<{ tagName: string, index: number }>,\n      htmlContext: string,\n    }): Promise<{ updatedSource: string }>,\n    updateEmailTemplate(id: string, tsxSource: string, themeId: string | null | false): Promise<{ renderedHtml: string }>,\n    createEmailTemplate(displayName: string): Promise<{ id: string }>,\n    deleteEmailTemplate(id: string): Promise<void>,\n\n    setupPayments(): Promise<{ url: string }>,\n    createStripeWidgetAccountSession(): Promise<{ client_secret: string }>,\n    getPaymentMethodConfigs(): Promise<{ configId: string, methods: Array<{ id: string, name: string, enabled: boolean, available: boolean, overridable: boolean }> } | null>,\n    updatePaymentMethodConfigs(configId: string, updates: Record<string, 'on' | 'off'>): Promise<void>,\n    createEmailDraft(options: { displayName: string, themeId?: string | undefined | false, tsxSource?: string }): Promise<{ id: string }>,\n    updateEmailDraft(id: string, data: { displayName?: string, themeId?: string | undefined | false, tsxSource?: string }): Promise<void>,\n    deleteEmailDraft(id: string): Promise<void>,\n    createItemQuantityChange(options: (\n      { userId: string, itemId: string, quantity: number, expiresAt?: string, description?: string } |\n      { teamId: string, itemId: string, quantity: number, expiresAt?: string, description?: string } |\n      { customCustomerId: string, itemId: string, quantity: number, expiresAt?: string, description?: string }\n    )): Promise<void>,\n    refundTransaction(options: {\n      type: \"subscription\" | \"one-time-purchase\",\n      id: string,\n      refundEntries: Array<{ entryIndex: number, quantity: number, amountUsd: MoneyAmount }>,\n    }): Promise<void>,\n    queryAnalytics(options: AnalyticsQueryOptions): Promise<AnalyticsQueryResponse>,\n\n    listSessionReplays(options?: ListSessionReplaysOptions): Promise<ListSessionReplaysResult>,\n    listSessionReplayChunks(sessionReplayId: string, options?: ListSessionReplayChunksOptions): Promise<ListSessionReplayChunksResult>,\n    getSessionReplayChunkEvents(sessionReplayId: string, chunkId: string): Promise<AdminGetSessionReplayChunkEventsResponse>,\n    getSessionReplayEvents(sessionReplayId: string, options?: { offset?: number, limit?: number }): Promise<SessionReplayAllEventsResult>,\n\n    // Email Outbox methods\n    listOutboxEmails(options?: EmailOutboxListOptions): Promise<EmailOutboxListResult>,\n    getOutboxEmail(id: string): Promise<AdminEmailOutbox>,\n    updateOutboxEmail(id: string, options: EmailOutboxUpdateOptions): Promise<AdminEmailOutbox>,\n    pauseOutboxEmail(id: string): Promise<AdminEmailOutbox>,\n    unpauseOutboxEmail(id: string): Promise<AdminEmailOutbox>,\n    cancelOutboxEmail(id: string): Promise<AdminEmailOutbox>,\n  }\n  & StackServerApp<HasTokenStore, ProjectId>\n);\nexport type StackAdminAppConstructor = {\n  new <\n    HasTokenStore extends boolean,\n    ProjectId extends string\n  >(options: StackAdminAppConstructorOptions<HasTokenStore, ProjectId>): StackAdminApp<HasTokenStore, ProjectId>,\n  new(options: StackAdminAppConstructorOptions<boolean, string>): StackAdminApp<boolean, string>,\n};\nexport const StackAdminApp: StackAdminAppConstructor = _StackAdminAppImpl;\n"
  },
  {
    "path": "apps/interfaces/client-app.ts",
    "content": "import { KnownErrors } from \"@stackframe/stack-shared\";\nimport { CurrentUserCrud } from \"@stackframe/stack-shared/dist/interface/crud/current-user\";\nimport { Result } from \"@stackframe/stack-shared/dist/utils/results\";\nimport { AsyncStoreProperty, AuthLike, GetCurrentPartialUserOptions, GetCurrentUserOptions, HandlerUrls, OAuthScopesOnSignIn, RedirectMethod, RedirectToOptions, TokenStoreInit, stackAppInternalsSymbol } from \"../../common\";\nimport { CustomerInvoicesList, CustomerInvoicesRequestOptions, CustomerProductsList, CustomerProductsRequestOptions, Item } from \"../../customers\";\nimport { Project } from \"../../projects\";\nimport { ProjectCurrentUser, SyncedPartialUser, TokenPartialUser } from \"../../users\";\nimport { _StackClientAppImpl } from \"../implementations\";\nimport { AnalyticsOptions } from \"../implementations/session-replay\";\n\nexport type StackClientAppConstructorOptions<HasTokenStore extends boolean, ProjectId extends string> = {\n  baseUrl?: string | { browser: string, server: string },\n  extraRequestHeaders?: Record<string, string>,\n  projectId?: ProjectId,\n  publishableClientKey?: string,\n  urls?: Partial<HandlerUrls>,\n  oauthScopesOnSignIn?: Partial<OAuthScopesOnSignIn>,\n  tokenStore?: TokenStoreInit<HasTokenStore>,\n  redirectMethod?: RedirectMethod,\n  inheritsFrom?: StackClientApp<any, any>,\n\n  /**\n   * By default, the Stack app will automatically prefetch some data from Stack's server when this app is first\n   * constructed. This improves the performance of your app, but will create network requests that are unnecessary if\n   * the app is never used or disposed of immediately. To disable this behavior, set this option to true.\n   */\n  noAutomaticPrefetch?: boolean,\n\n  /**\n   * Options for analytics and session recording. Replays are disabled by default;\n   * set `{ replays: { enabled: true } }` to opt in.\n   */\n  analytics?: AnalyticsOptions,\n} & (\n  { tokenStore: TokenStoreInit<HasTokenStore> } | { tokenStore?: undefined, inheritsFrom: StackClientApp<HasTokenStore, any> }\n) & (\n  string extends ProjectId ? unknown : ({ projectId: ProjectId } | { inheritsFrom: StackClientApp<any, ProjectId> })\n);\n\n\nexport type StackClientAppJson<HasTokenStore extends boolean, ProjectId extends string> = StackClientAppConstructorOptions<HasTokenStore, ProjectId> & { inheritsFrom?: undefined } & {\n  uniqueIdentifier: string,\n  // note: if you add more fields here, make sure to ensure the checkString in the constructor has/doesn't have them\n};\n\nexport type StackClientApp<HasTokenStore extends boolean = boolean, ProjectId extends string = string> = (\n  & {\n    readonly projectId: ProjectId,\n\n    /**\n     * The version of the Stack Auth SDK.\n     */\n    readonly version: string,\n\n    readonly urls: Readonly<HandlerUrls>,\n\n    signInWithOAuth(provider: string, options?: { returnTo?: string }): Promise<void>,\n    signInWithCredential(options: { email: string, password: string, noRedirect?: boolean }): Promise<Result<undefined, KnownErrors[\"EmailPasswordMismatch\"] | KnownErrors[\"InvalidTotpCode\"]>>,\n    signUpWithCredential(options: { email: string, password: string, noRedirect?: boolean } & ({ noVerificationCallback: true } | { noVerificationCallback?: false, verificationCallbackUrl?: string })): Promise<Result<undefined, KnownErrors[\"UserWithEmailAlreadyExists\"] | KnownErrors[\"PasswordRequirementsNotMet\"]>>,\n    signInWithPasskey(): Promise<Result<undefined, KnownErrors[\"PasskeyAuthenticationFailed\"] | KnownErrors[\"InvalidTotpCode\"] | KnownErrors[\"PasskeyWebAuthnError\"]>>,\n    callOAuthCallback(): Promise<boolean>,\n    promptCliLogin(options: { appUrl: string, expiresInMillis?: number }): Promise<Result<string, KnownErrors[\"CliAuthError\"] | KnownErrors[\"CliAuthExpiredError\"] | KnownErrors[\"CliAuthUsedError\"]>>,\n    sendForgotPasswordEmail(email: string, options?: { callbackUrl?: string }): Promise<Result<undefined, KnownErrors[\"UserNotFound\"]>>,\n    sendMagicLinkEmail(email: string, options?: { callbackUrl?: string }): Promise<Result<{ nonce: string }, KnownErrors[\"RedirectUrlNotWhitelisted\"]>>,\n    resetPassword(options: { code: string, password: string }): Promise<Result<undefined, KnownErrors[\"VerificationCodeError\"]>>,\n    verifyPasswordResetCode(code: string): Promise<Result<undefined, KnownErrors[\"VerificationCodeError\"]>>,\n    verifyTeamInvitationCode(code: string): Promise<Result<undefined, KnownErrors[\"VerificationCodeError\"]>>,\n    acceptTeamInvitation(code: string): Promise<Result<undefined, KnownErrors[\"VerificationCodeError\"]>>,\n    getTeamInvitationDetails(code: string): Promise<Result<{ teamDisplayName: string }, KnownErrors[\"VerificationCodeError\"]>>,\n    verifyEmail(code: string): Promise<Result<undefined, KnownErrors[\"VerificationCodeError\"]>>,\n    signInWithMagicLink(code: string, options?: { noRedirect?: boolean }): Promise<Result<undefined, KnownErrors[\"VerificationCodeError\"] | KnownErrors[\"InvalidTotpCode\"]>>,\n    signInWithMfa(otp: string, code: string, options?: { noRedirect?: boolean }): Promise<Result<undefined, KnownErrors[\"VerificationCodeError\"] | KnownErrors[\"InvalidTotpCode\"]>>,\n\n    redirectToOAuthCallback(): Promise<void>,\n\n    getConvexClientAuth(options: HasTokenStore extends false ? { tokenStore: TokenStoreInit } : { tokenStore?: TokenStoreInit }): (args: { forceRefreshToken: boolean }) => Promise<string | null>,\n    getConvexHttpClientAuth(options: { tokenStore: TokenStoreInit }): Promise<string>,\n\n    // IF_PLATFORM react-like\n    useUser(options: GetCurrentUserOptions<HasTokenStore> & { or: 'redirect' }): ProjectCurrentUser<ProjectId>,\n    useUser(options: GetCurrentUserOptions<HasTokenStore> & { or: 'throw' }): ProjectCurrentUser<ProjectId>,\n    useUser(options: GetCurrentUserOptions<HasTokenStore> & { or: 'anonymous' }): ProjectCurrentUser<ProjectId>,\n    useUser(options?: GetCurrentUserOptions<HasTokenStore>): ProjectCurrentUser<ProjectId> | null,\n    // END_PLATFORM\n\n    getUser(options: GetCurrentUserOptions<HasTokenStore> & { or: 'redirect' }): Promise<ProjectCurrentUser<ProjectId>>,\n    getUser(options: GetCurrentUserOptions<HasTokenStore> & { or: 'throw' }): Promise<ProjectCurrentUser<ProjectId>>,\n    getUser(options: GetCurrentUserOptions<HasTokenStore> & { or: 'anonymous' }): Promise<ProjectCurrentUser<ProjectId>>,\n    getUser(options?: GetCurrentUserOptions<HasTokenStore>): Promise<ProjectCurrentUser<ProjectId> | null>,\n\n    cancelSubscription(options: { productId: string, subscriptionId?: string } | { productId: string, subscriptionId?: string, teamId: string }): Promise<void>,\n\n    // note: we don't special-case 'anonymous' here to return non-null, see GetPartialUserOptions for more details\n    getPartialUser(options: GetCurrentPartialUserOptions<HasTokenStore> & { from: 'token' }): Promise<TokenPartialUser | null>,\n    getPartialUser(options: GetCurrentPartialUserOptions<HasTokenStore> & { from: 'convex' }): Promise<TokenPartialUser | null>,\n    getPartialUser(options: GetCurrentPartialUserOptions<HasTokenStore>): Promise<SyncedPartialUser | TokenPartialUser | null>,\n    // IF_PLATFORM react-like\n    usePartialUser(options: GetCurrentPartialUserOptions<HasTokenStore> & { from: 'token' }): TokenPartialUser | null,\n    usePartialUser(options: GetCurrentPartialUserOptions<HasTokenStore> & { from: 'convex' }): TokenPartialUser | null,\n    usePartialUser(options: GetCurrentPartialUserOptions<HasTokenStore>): SyncedPartialUser | TokenPartialUser | null,\n    // END_PLATFORM\n    useNavigate(): (to: string) => void, // THIS_LINE_PLATFORM react-like\n\n    [stackAppInternalsSymbol]: {\n      toClientJson(): StackClientAppJson<HasTokenStore, ProjectId>,\n      setCurrentUser(userJsonPromise: Promise<CurrentUserCrud['Client']['Read'] | null>): void,\n      getConstructorOptions(): StackClientAppConstructorOptions<HasTokenStore, ProjectId> & { inheritsFrom?: undefined },\n      sendSessionReplayBatch(body: string, options: { keepalive: boolean }): Promise<Result<Response, Error>>,\n      sendAnalyticsEventBatch(body: string, options: { keepalive: boolean }): Promise<Result<Response, Error>>,\n    },\n  }\n  & AsyncStoreProperty<\"project\", [], Project, false>\n  & AsyncStoreProperty<\n    \"item\",\n    [{ itemId: string, userId: string } | { itemId: string, teamId: string } | { itemId: string, customCustomerId: string }],\n    Item,\n    false\n  >\n  & AsyncStoreProperty<\n    \"products\",\n    [options: CustomerProductsRequestOptions],\n    CustomerProductsList,\n    true\n  >\n  & AsyncStoreProperty<\n    \"invoices\",\n    [options: CustomerInvoicesRequestOptions],\n    CustomerInvoicesList,\n    true\n  >\n  & { [K in `redirectTo${Capitalize<keyof Omit<HandlerUrls, 'handler' | 'oauthCallback'>>}`]: (options?: RedirectToOptions) => Promise<void> }\n  & AuthLike<HasTokenStore extends false ? { tokenStore: TokenStoreInit } : { tokenStore?: TokenStoreInit }>\n);\nexport type StackClientAppConstructor = {\n  new <\n    TokenStoreType extends string,\n    HasTokenStore extends (TokenStoreType extends {} ? true : boolean),\n    ProjectId extends string\n  >(options: StackClientAppConstructorOptions<HasTokenStore, ProjectId>): StackClientApp<HasTokenStore, ProjectId>,\n  new(options: StackClientAppConstructorOptions<boolean, string>): StackClientApp<boolean, string>,\n\n  [stackAppInternalsSymbol]: {\n    fromClientJson<HasTokenStore extends boolean, ProjectId extends string>(\n      json: StackClientAppJson<HasTokenStore, ProjectId>\n    ): StackClientApp<HasTokenStore, ProjectId>,\n  },\n};\nexport const StackClientApp: StackClientAppConstructor = _StackClientAppImpl;\n"
  },
  {
    "path": "apps/interfaces/server-app.ts",
    "content": "import { KnownErrors } from \"@stackframe/stack-shared\";\nimport { Result } from \"@stackframe/stack-shared/dist/utils/results\";\nimport type { GenericQueryCtx } from \"convex/server\";\nimport { AsyncStoreProperty, GetCurrentPartialUserOptions, GetCurrentUserOptions } from \"../../common\";\nimport { CustomerProductsList, CustomerProductsRequestOptions, InlineProduct, ServerItem } from \"../../customers\";\nimport { DataVaultStore } from \"../../data-vault\";\nimport { EmailDeliveryInfo, SendEmailOptions } from \"../../email\";\nimport { ServerListUsersOptions, ServerTeam, ServerTeamCreateOptions } from \"../../teams\";\nimport { ProjectCurrentServerUser, ServerOAuthProvider, ServerUser, ServerUserCreateOptions, SyncedPartialServerUser, TokenPartialUser } from \"../../users\";\nimport { _StackServerAppImpl } from \"../implementations\";\nimport { StackClientApp, StackClientAppConstructorOptions } from \"./client-app\";\n\n\nexport type StackServerAppConstructorOptions<HasTokenStore extends boolean, ProjectId extends string> = StackClientAppConstructorOptions<HasTokenStore, ProjectId> & {\n  secretServerKey?: string,\n};\n\nexport type StackServerApp<HasTokenStore extends boolean = boolean, ProjectId extends string = string> = (\n  & {\n    createTeam(data: ServerTeamCreateOptions): Promise<ServerTeam>,\n    /**\n     * @deprecated use `getUser()` instead\n     */\n    getServerUser(): Promise<ProjectCurrentServerUser<ProjectId> | null>,\n\n    createUser(options: ServerUserCreateOptions): Promise<ServerUser>,\n    grantProduct(options: (\n      ({ userId: string } | { teamId: string } | { customCustomerId: string }) &\n      ({ productId: string } | { product: InlineProduct }) &\n      { quantity?: number }\n    )): Promise<void>,\n\n    // IF_PLATFORM react-like\n    useUser(options: GetCurrentUserOptions<HasTokenStore> & { or: 'redirect' }): ProjectCurrentServerUser<ProjectId>,\n    useUser(options: GetCurrentUserOptions<HasTokenStore> & { or: 'throw' }): ProjectCurrentServerUser<ProjectId>,\n    useUser(options: GetCurrentUserOptions<HasTokenStore> & { or: 'anonymous' }): ProjectCurrentServerUser<ProjectId>,\n    useUser(options?: GetCurrentUserOptions<HasTokenStore>): ProjectCurrentServerUser<ProjectId> | null,\n    useUser(id: string): ServerUser | null,\n    useUser(options: { apiKey: string, or?: \"return-null\" | \"anonymous\" }): ServerUser | null,\n    useUser(options: { from: \"convex\", ctx: GenericQueryCtx<any>, or?: \"return-null\" | \"anonymous\" }): ServerUser | null,\n    // END_PLATFORM\n\n    getUser(options: GetCurrentUserOptions<HasTokenStore> & { or: 'redirect' }): Promise<ProjectCurrentServerUser<ProjectId>>,\n    getUser(options: GetCurrentUserOptions<HasTokenStore> & { or: 'throw' }): Promise<ProjectCurrentServerUser<ProjectId>>,\n    getUser(options: GetCurrentUserOptions<HasTokenStore> & { or: 'anonymous' }): Promise<ProjectCurrentServerUser<ProjectId>>,\n    getUser(options?: GetCurrentUserOptions<HasTokenStore>): Promise<ProjectCurrentServerUser<ProjectId> | null>,\n    getUser(id: string): Promise<ServerUser | null>,\n    getUser(options: { apiKey: string, or?: \"return-null\" | \"anonymous\" }): Promise<ServerUser | null>,\n    getUser(options: { from: \"convex\", ctx: GenericQueryCtx<any>, or?: \"return-null\" | \"anonymous\" }): Promise<ServerUser | null>,\n\n    // note: we don't special-case 'anonymous' here to return non-null, see GetPartialUserOptions for more details\n    getPartialUser(options: GetCurrentPartialUserOptions<HasTokenStore> & { from: 'token' }): Promise<TokenPartialUser | null>,\n    getPartialUser(options: GetCurrentPartialUserOptions<HasTokenStore> & { from: 'convex' }): Promise<TokenPartialUser | null>,\n    getPartialUser(options: GetCurrentPartialUserOptions<HasTokenStore>): Promise<SyncedPartialServerUser | TokenPartialUser | null>,\n    // IF_PLATFORM react-like\n    usePartialUser(options: GetCurrentPartialUserOptions<HasTokenStore> & { from: 'token' }): TokenPartialUser | null,\n    usePartialUser(options: GetCurrentPartialUserOptions<HasTokenStore> & { from: 'convex' }): TokenPartialUser | null,\n    usePartialUser(options: GetCurrentPartialUserOptions<HasTokenStore>): SyncedPartialServerUser | TokenPartialUser | null,\n    // END_PLATFORM\n    // IF_PLATFORM react-like\n    useTeam(id: string): ServerTeam | null,\n    useTeam(options: { apiKey: string }): ServerTeam | null,\n    // END_PLATFORM\n    getTeam(id: string): Promise<ServerTeam | null>,\n    getTeam(options: { apiKey: string }): Promise<ServerTeam | null>,\n\n\n    useUsers(options?: ServerListUsersOptions): ServerUser[] & { nextCursor: string | null }, // THIS_LINE_PLATFORM react-like\n    listUsers(options?: ServerListUsersOptions): Promise<ServerUser[] & { nextCursor: string | null }>,\n\n    // TODO this should actually be on ServerUser\n    createOAuthProvider(options: {\n      userId: string,\n      accountId: string,\n      providerConfigId: string,\n      email: string,\n      allowSignIn: boolean,\n      allowConnectedAccounts: boolean,\n    }): Promise<Result<ServerOAuthProvider, InstanceType<typeof KnownErrors.OAuthProviderAccountIdAlreadyUsedForSignIn>>>,\n\n    sendEmail(options: SendEmailOptions): Promise<void>,\n\n    getEmailDeliveryStats(): Promise<EmailDeliveryInfo>,\n    // IF_PLATFORM react-like\n    useEmailDeliveryStats(): EmailDeliveryInfo,\n    // END_PLATFORM\n  }\n  & AsyncStoreProperty<\"user\", [id: string], ServerUser | null, false>\n  & Omit<AsyncStoreProperty<\"users\", [], ServerUser[], true>, \"listUsers\" | \"useUsers\">\n  & AsyncStoreProperty<\"teams\", [], ServerTeam[], true>\n  & AsyncStoreProperty<\"dataVaultStore\", [id: string], DataVaultStore, false>\n  & AsyncStoreProperty<\n    \"item\",\n    [{ itemId: string, userId: string } | { itemId: string, teamId: string } | { itemId: string, customCustomerId: string }],\n    ServerItem,\n    false\n  >\n  & AsyncStoreProperty<\n    \"products\",\n    [options: CustomerProductsRequestOptions],\n    CustomerProductsList,\n    true\n  >\n  & StackClientApp<HasTokenStore, ProjectId>\n);\nexport type StackServerAppConstructor = {\n  new <\n    TokenStoreType extends string,\n    HasTokenStore extends (TokenStoreType extends {} ? true : boolean),\n    ProjectId extends string\n  >(options: StackServerAppConstructorOptions<HasTokenStore, ProjectId>): StackServerApp<HasTokenStore, ProjectId>,\n  new (options: StackServerAppConstructorOptions<boolean, string>): StackServerApp<boolean, string>,\n};\nexport const StackServerApp: StackServerAppConstructor = _StackServerAppImpl;\n"
  },
  {
    "path": "common.ts",
    "content": "import { ProviderType } from \"@stackframe/stack-shared/dist/utils/oauth\";\nimport type { GenericQueryCtx, UserIdentity } from \"convex/server\";\n\nexport type RedirectToOptions = {\n  replace?: boolean,\n  noRedirectBack?: boolean,\n};\n\nexport type AsyncStoreProperty<Name extends string, Args extends any[], Value, IsMultiple extends boolean> =\n  & { [key in `${IsMultiple extends true ? \"list\" : \"get\"}${Capitalize<Name>}`]: (...args: Args) => Promise<Value> }\n  & { [key in `use${Capitalize<Name>}`]: (...args: Args) => Value } // THIS_LINE_PLATFORM react-like\n\nexport type EmailConfig = {\n  host: string,\n  port: number,\n  username: string,\n  password: string,\n  senderEmail: string,\n  senderName: string,\n}\n\nexport type RedirectMethod = \"window\"\n  | \"nextjs\" // THIS_LINE_PLATFORM next\n  | \"none\"\n  | {\n    useNavigate: () => (to: string) => void,\n    navigate?: (to: string) => void,\n  }\n\n\nexport type GetCurrentUserOptions<HasTokenStore> =\n  & {\n    or?: 'redirect' | 'throw' | 'return-null' | 'anonymous' | /** @deprecated */ 'anonymous-if-exists[deprecated]',\n    /**\n     * Whether to include restricted users (users who haven't completed onboarding requirements like email verification).\n     * By default, restricted users are filtered out (treated similar to anonymous users).\n     *\n     * Note: This option cannot be set to false when `or: 'anonymous'` is used, as all anonymous users are also restricted.\n     *\n     * @default false\n     */\n    includeRestricted?: boolean,\n    tokenStore?: TokenStoreInit,\n  }\n  & (HasTokenStore extends false ? {\n    tokenStore: TokenStoreInit,\n  } : {});\n\nexport type ConvexCtx =\n| GenericQueryCtx<any>\n| { auth: { getUserIdentity: () => Promise<UserIdentity | null> } };\n\nexport type GetCurrentPartialUserOptions<HasTokenStore> =\n  & {\n    or?: 'return-null' | 'anonymous',  // note: unlike normal getUser, 'anonymous' still returns null sometimes (eg. if no token is present)\n    tokenStore?: TokenStoreInit,\n  }\n  & (\n    | {\n      from: 'token',\n    }\n    | {\n      from: 'convex',\n      ctx: ConvexCtx,\n    }\n  )\n  & (HasTokenStore extends false ? {\n    tokenStore: TokenStoreInit,\n  } : {});\n\nexport type RequestLike = {\n  headers: {\n    get: (name: string) => string | null,\n  },\n};\n\nexport type TokenStoreInit<HasTokenStore extends boolean = boolean> =\n  HasTokenStore extends true ? (\n    | \"cookie\"\n    | \"nextjs-cookie\"\n    | \"memory\"\n    | RequestLike\n    | { accessToken: string, refreshToken: string }\n  )\n  : HasTokenStore extends false ? null\n  : TokenStoreInit<true> | TokenStoreInit<false>;\n\nexport type HandlerUrls = {\n  handler: string,\n  signIn: string,\n  signUp: string,\n  afterSignIn: string,\n  afterSignUp: string,\n  signOut: string,\n  afterSignOut: string,\n  emailVerification: string,\n  passwordReset: string,\n  forgotPassword: string,\n  home: string,\n  oauthCallback: string,\n  magicLinkCallback: string,\n  accountSettings: string,\n  teamInvitation: string,\n  mfa: string,\n  error: string,\n  onboarding: string,\n}\n\nexport type OAuthScopesOnSignIn = {\n  [key in ProviderType]: string[];\n};\n\n/**\n * Contains the authentication methods without session-related fields.\n * Used for apps that have token storage capabilities.\n */\nexport type AuthLike<ExtraOptions = {}> = {\n  signOut(options?: { redirectUrl?: URL | string } & ExtraOptions): Promise<void>,\n  signOut(options?: { redirectUrl?: URL | string }): Promise<void>,\n\n  /**\n   * Returns the current access token, or null if the user is not signed in.\n   *\n   * The access token is a short-lived JWT that can be used to authenticate requests to external servers.\n   * It will be automatically refreshed when it expires.\n   */\n  getAccessToken(options?: {} & ExtraOptions): Promise<string | null>,\n  useAccessToken(options?: {} & ExtraOptions): string | null, // THIS_LINE_PLATFORM react-like\n\n  /**\n   * Returns the current refresh token, or null if the user is not signed in.\n   *\n   * The refresh token is a long-lived token that can be used to obtain new access tokens.\n   * It should be kept secret and never exposed to the client.\n   */\n  getRefreshToken(options?: {} & ExtraOptions): Promise<string | null>,\n  useRefreshToken(options?: {} & ExtraOptions): string | null, // THIS_LINE_PLATFORM react-like\n\n  /**\n   * Returns headers for sending authenticated HTTP requests to external servers. Most commonly used in cross-origin\n   * requests. Similar to `getAuthJson`, but specifically for HTTP requests.\n   *\n   * If you are using `tokenStore: \"cookie\"`, you don't need this for same-origin requests. However, most\n   * browsers now disable third-party cookies by default, so we must pass authentication tokens by header instead\n   * if the client and server are on different origins.\n   *\n   * This function returns a header object that can be used with `fetch` or other HTTP request libraries to send\n   * authenticated requests.\n   *\n   * On the server, you can then pass in the `Request` object to the `tokenStore` option\n   * of your Stack app. Please note that CORS does not allow most headers by default, so you\n   * must include `x-stack-auth` in the [`Access-Control-Allow-Headers` header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Headers)\n   * of the CORS preflight response.\n   *\n   * If you are not using HTTP (and hence cannot set headers), you will need to use the `getAccessToken()` and\n   * `getRefreshToken()` functions instead.\n   *\n   * Example:\n   *\n   * ```ts\n   * // client\n   * const res = await fetch(\"https://api.example.com\", {\n   *   headers: {\n   *     ...await stackApp.getAuthHeaders()\n   *     // you can also add your own headers here\n   *   },\n   * });\n   *\n   * // server\n   * function handleRequest(req: Request) {\n   *   const user = await stackServerApp.getUser({ tokenStore: req });\n   *   return new Response(\"Welcome, \" + user.displayName);\n   * }\n   * ```\n   */\n  getAuthHeaders(options?: {} & ExtraOptions): Promise<{ \"x-stack-auth\": string }>,\n  useAuthHeaders(options?: {} & ExtraOptions): { \"x-stack-auth\": string }, // THIS_LINE_PLATFORM react-like\n\n  /**\n   * @deprecated Use `getAccessToken()` and `getRefreshToken()` instead.\n   *\n   * Creates a JSON-serializable object containing the information to authenticate a user on an external server.\n   * Similar to `getAuthHeaders`, but returns an object that can be sent over any protocol instead of just\n   * HTTP headers.\n   *\n   * While `getAuthHeaders` is the recommended way to send authentication tokens over HTTP, your app may use\n   * a different protocol, for example WebSockets or gRPC. This function returns a token object that can be JSON-serialized and sent to the server in any way you like.\n   *\n   * On the server, you can pass in this token object into the `tokenStore` option to fetch user details.\n   *\n   * Example:\n   *\n   * ```ts\n   * // client\n   * const res = await rpcCall(rpcEndpoint, {\n   *   data: {\n   *     auth: await stackApp.getAuthJson(),\n   *   },\n   * });\n   *\n   * // server\n   * function handleRequest(data) {\n   *   const user = await stackServerApp.getUser({ tokenStore: data.auth });\n   *   return new Response(\"Welcome, \" + user.displayName);\n   * }\n   * ```\n   */\n  getAuthJson(options?: {} & ExtraOptions): Promise<{ accessToken: string | null, refreshToken: string | null }>,\n  /** @deprecated Use `useAccessToken()` and `useRefreshToken()` instead. */\n  useAuthJson(options?: {} & ExtraOptions): { accessToken: string | null, refreshToken: string | null }, // THIS_LINE_PLATFORM react-like\n};\n\n/** @internal */\nexport const stackAppInternalsSymbol = Symbol.for(\"StackAuth--DO-NOT-USE-OR-YOU-WILL-BE-FIRED--StackAppInternals\");\n"
  },
  {
    "path": "connected-accounts/index.ts",
    "content": "import { KnownErrors } from \"@stackframe/stack-shared\";\nimport { Result } from \"@stackframe/stack-shared/dist/utils/results\";\n\nexport type Connection = {\n  /**\n   * @deprecated Use `provider` instead. This field returns the provider for backward compatibility.\n   */\n  id: string,\n  /** Provider config ID (e.g., \"google\", \"github\") */\n  provider: string,\n  /** Account ID from the OAuth provider (e.g., Google user ID) */\n  providerAccountId: string,\n};\n\nexport type OAuthConnection = {\n  /**\n   * Get an OAuth access token for this connected account.\n   *\n   * Returns `{ status: \"ok\", data: { accessToken } }` on success, or\n   * `{ status: \"error\", error: KnownErrors[\"OAuthAccessTokenNotAvailable\"] }` if the\n   * refresh token has been revoked/expired or the requested scopes are not available.\n   *\n   * @param options.scopes - If provided, only returns a token that has all of these scopes.\n   */\n  getAccessToken(options?: { scopes?: string[] }): Promise<Result<{ accessToken: string }, KnownErrors[\"OAuthAccessTokenNotAvailable\"]>>,\n  /**\n   * React hook to get an OAuth access token for this connected account.\n   *\n   * Returns `{ status: \"ok\", data: { accessToken } }` on success, or\n   * `{ status: \"error\", error: KnownErrors[\"OAuthAccessTokenNotAvailable\"] }` if the\n   * refresh token has been revoked/expired or the requested scopes are not available.\n   *\n   * @param options.scopes - If provided, only returns a token that has all of these scopes.\n   */\n  useAccessToken(options?: { scopes?: string[] }): Result<{ accessToken: string }, KnownErrors[\"OAuthAccessTokenNotAvailable\"]>, // THIS_LINE_PLATFORM react-like\n} & Connection;\n\n/**\n * @deprecated Used by legacy `getConnectedAccount(providerId)`. Use `OAuthConnection` instead,\n * which returns a `Result` from `getAccessToken`/`useAccessToken` instead of throwing.\n */\nexport type DeprecatedOAuthConnection = {\n  getAccessToken(): Promise<{ accessToken: string }>,\n  useAccessToken(): { accessToken: string }, // THIS_LINE_PLATFORM react-like\n} & Connection;\n"
  },
  {
    "path": "contact-channels/index.ts",
    "content": "import { ContactChannelsCrud } from \"@stackframe/stack-shared/dist/interface/crud/contact-channels\";\n\n\nexport type ContactChannel = {\n  id: string,\n  value: string,\n  type: 'email',\n  isPrimary: boolean,\n  isVerified: boolean,\n  usedForAuth: boolean,\n\n  sendVerificationEmail(options?: { callbackUrl?: string }): Promise<void>,\n  update(data: ContactChannelUpdateOptions): Promise<void>,\n  delete(): Promise<void>,\n}\n\nexport type ContactChannelCreateOptions = {\n  value: string,\n  type: 'email',\n  usedForAuth: boolean,\n  isPrimary?: boolean,\n}\n\nexport function contactChannelCreateOptionsToCrud(userId: string, options: ContactChannelCreateOptions): ContactChannelsCrud[\"Client\"][\"Create\"] {\n  return {\n    value: options.value,\n    type: options.type,\n    used_for_auth: options.usedForAuth,\n    is_primary: options.isPrimary,\n    user_id: userId,\n  };\n}\n\nexport type ContactChannelUpdateOptions = {\n  usedForAuth?: boolean,\n  value?: string,\n  isPrimary?: boolean,\n}\n\nexport function contactChannelUpdateOptionsToCrud(options: ContactChannelUpdateOptions): ContactChannelsCrud[\"Client\"][\"Update\"] {\n  return {\n    value: options.value,\n    used_for_auth: options.usedForAuth,\n    is_primary: options.isPrimary,\n  };\n}\n\nexport type ServerContactChannel = ContactChannel & {\n  update(data: ServerContactChannelUpdateOptions): Promise<void>,\n}\nexport type ServerContactChannelUpdateOptions = ContactChannelUpdateOptions & {\n  isVerified?: boolean,\n}\n\nexport function serverContactChannelUpdateOptionsToCrud(options: ServerContactChannelUpdateOptions): ContactChannelsCrud[\"Server\"][\"Update\"] {\n  return {\n    value: options.value,\n    is_verified: options.isVerified,\n    used_for_auth: options.usedForAuth,\n    is_primary: options.isPrimary,\n  };\n}\n\nexport type ServerContactChannelCreateOptions = ContactChannelCreateOptions & {\n  isVerified?: boolean,\n}\nexport function serverContactChannelCreateOptionsToCrud(userId: string, options: ServerContactChannelCreateOptions): ContactChannelsCrud[\"Server\"][\"Create\"] {\n  return {\n    type: options.type,\n    value: options.value,\n    is_verified: options.isVerified,\n    user_id: userId,\n    used_for_auth: options.usedForAuth,\n    is_primary: options.isPrimary,\n  };\n}\n"
  },
  {
    "path": "customers/index.ts",
    "content": "import { inlineProductSchema } from \"@stackframe/stack-shared/dist/schema-fields\";\nimport * as yup from \"yup\";\nimport { AsyncStoreProperty } from \"../common\";\n\nexport type InlineProduct = yup.InferType<typeof inlineProductSchema>;\n\nexport type Item = {\n  displayName: string,\n  /**\n   * May be negative.\n   */\n  quantity: number,\n  /**\n   * Equal to Math.max(0, quantity).\n   */\n  nonNegativeQuantity: number,\n};\n\nexport type ServerItem = Item & {\n  increaseQuantity(amount: number): Promise<void>,\n  /**\n   * Decreases the quantity by the given amount.\n   *\n   * Note that you may want to use tryDecreaseQuantity instead, as it will prevent the quantity from going below 0 in a race-condition-free way.\n   */\n  decreaseQuantity(amount: number): Promise<void>,\n  /**\n   * Decreases the quantity by the given amount and returns true if the result is non-negative; returns false and does nothing if the result would be negative.\n   *\n   * Most useful for pre-paid credits.\n   */\n  tryDecreaseQuantity(amount: number): Promise<boolean>,\n};\n\nexport type CustomerProduct = {\n  id: string | null,\n  quantity: number,\n  displayName: string,\n  customerType: \"user\" | \"team\" | \"custom\",\n  isServerOnly: boolean,\n  stackable: boolean,\n  type: \"one_time\" | \"subscription\",\n  subscription: null | {\n    subscriptionId: string | null,\n    currentPeriodEnd: Date | null,\n    cancelAtPeriodEnd: boolean,\n    isCancelable: boolean,\n  },\n  switchOptions?: Array<{\n    productId: string,\n    displayName: string,\n    prices: InlineProduct[\"prices\"],\n  }>,\n};\n\nexport type CustomerProductsList = CustomerProduct[] & {\n  nextCursor: string | null,\n};\n\nexport type CustomerProductsListOptions = {\n  cursor?: string,\n  limit?: number,\n};\n\nexport type CustomerProductsRequestOptions =\n  | ({ userId: string } & CustomerProductsListOptions)\n  | ({ teamId: string } & CustomerProductsListOptions)\n  | ({ customCustomerId: string } & CustomerProductsListOptions);\n\nexport type CustomerInvoiceStatus = \"draft\" | \"open\" | \"paid\" | \"uncollectible\" | \"void\" | null;\n\nexport type CustomerInvoice = {\n  createdAt: Date,\n  status: CustomerInvoiceStatus,\n  amountTotal: number,\n  hostedInvoiceUrl: string | null,\n};\n\nexport type CustomerInvoicesList = CustomerInvoice[] & {\n  nextCursor: string | null,\n};\n\nexport type CustomerInvoicesListOptions = {\n  cursor?: string,\n  limit?: number,\n};\n\nexport type CustomerInvoicesRequestOptions =\n  | ({ userId: string } & CustomerInvoicesListOptions)\n  | ({ teamId: string } & CustomerInvoicesListOptions);\n\nexport type CustomerDefaultPaymentMethod = {\n  id: string,\n  brand: string | null,\n  last4: string | null,\n  exp_month: number | null,\n  exp_year: number | null,\n} | null;\n\nexport type CustomerBilling = {\n  hasCustomer: boolean,\n  defaultPaymentMethod: CustomerDefaultPaymentMethod,\n};\n\nexport type CustomerPaymentMethodSetupIntent = {\n  clientSecret: string,\n  stripeAccountId: string,\n};\n\nexport type Customer<IsServer extends boolean = false> =\n  & {\n    readonly id: string,\n\n    createCheckoutUrl(options: (\n      | { productId: string, returnUrl?: string }\n      | (IsServer extends true ? { product: InlineProduct, returnUrl?: string } : never)\n    )): Promise<string>,\n\n    createPaymentMethodSetupIntent(): Promise<CustomerPaymentMethodSetupIntent>,\n\n    setDefaultPaymentMethodFromSetupIntent(setupIntentId: string): Promise<CustomerDefaultPaymentMethod>,\n\n    switchSubscription(options: { fromProductId: string, toProductId: string, priceId?: string, quantity?: number }): Promise<void>,\n  }\n  & AsyncStoreProperty<\n    \"billing\",\n    [],\n    CustomerBilling,\n    false\n  >\n  & AsyncStoreProperty<\n    \"item\",\n    [itemId: string],\n    IsServer extends true ? ServerItem : Item,\n    false\n  >\n  & AsyncStoreProperty<\n    \"products\",\n    [options?: CustomerProductsListOptions],\n    CustomerProductsList,\n    true\n  >\n  & AsyncStoreProperty<\n    \"invoices\",\n    [options?: CustomerInvoicesListOptions],\n    CustomerInvoicesList,\n    true\n  >\n  & (IsServer extends true ? {\n    grantProduct(\n      product: { productId: string, quantity?: number } | { product: InlineProduct, quantity?: number },\n    ): Promise<void>,\n  } : {});\n"
  },
  {
    "path": "data-vault/index.ts",
    "content": "import { AsyncStoreProperty } from \"../common\";\n\nexport type DataVaultStore =\n  & {\n    id: string,\n    setValue: (key: string, value: string, options: { secret: string }) => Promise<void>,\n  }\n & AsyncStoreProperty<\"value\", [key: string, options: { secret: string }], string | null, false>;\n"
  },
  {
    "path": "email-templates/index.ts",
    "content": "import { EmailTemplateCrud, EmailTemplateType } from \"@stackframe/stack-shared/dist/interface/crud/email-templates\";\n\n\nexport type AdminEmailTemplate = {\n  type: EmailTemplateType,\n  subject: string,\n  content: any,\n  isDefault: boolean,\n}\n\nexport type AdminEmailTemplateUpdateOptions = {\n  subject?: string,\n  content?: any,\n};\nexport function adminEmailTemplateUpdateOptionsToCrud(options: AdminEmailTemplateUpdateOptions): EmailTemplateCrud['Admin']['Update'] {\n  return {\n    subject: options.subject,\n    content: options.content,\n  };\n}\n"
  },
  {
    "path": "email/index.ts",
    "content": "import { XOR } from \"@stackframe/stack-shared/dist/utils/types\";\n\nexport type AdminSentEmail = {\n  id: string,\n  to: string[],\n  subject: string,\n  recipient: string, // We'll derive this from to[0] for display\n  sentAt: Date, // We'll derive this from sent_at_millis for display\n  error?: unknown,\n}\n\nexport type AdminEmailOutboxRecipient =\n  | { type: \"user-primary-email\", userId: string }\n  | { type: \"user-custom-emails\", userId: string, emails: string[] }\n  | { type: \"custom-emails\", emails: string[] };\n\nexport type AdminEmailOutboxStatus =\n  | \"paused\"\n  | \"preparing\"\n  | \"rendering\"\n  | \"render-error\"\n  | \"scheduled\"\n  | \"queued\"\n  | \"sending\"\n  | \"server-error\"\n  | \"skipped\"\n  | \"bounced\"\n  | \"delivery-delayed\"\n  | \"sent\"\n  | \"opened\"\n  | \"clicked\"\n  | \"marked-as-spam\";\n\nexport type AdminEmailOutboxSimpleStatus =\n  | \"in-progress\"\n  | \"ok\"\n  | \"error\";\n\n// Error entry from a failed send attempt\nexport type AdminSendAttemptError = {\n  attemptNumber: number,\n  timestamp: string,\n  externalMessage: string,\n  externalDetails: Record<string, unknown>,\n  internalMessage: string,\n  internalDetails: Record<string, unknown>,\n};\n\n// =============================== BASE TYPES ===============================\n\n// Base fields present on all emails\ntype AdminEmailOutboxBase = {\n  id: string,\n  createdAt: Date,\n  updatedAt: Date,\n  to: AdminEmailOutboxRecipient,\n  scheduledAt: Date,\n  isPaused: false,\n  hasRendered: false,\n  hasDelivered: false,\n  // Retry tracking fields\n  sendRetries: number,\n  nextSendRetryAt: Date | null,\n  sendAttemptErrors: AdminSendAttemptError[] | null,\n};\n\n// Fields available after rendering completes successfully\n// Use Omit to properly override hasRendered from base\ntype AdminEmailOutboxRenderedFields = Omit<AdminEmailOutboxBase, \"hasRendered\"> & {\n  hasRendered: true,\n  startedRenderingAt: Date,\n  renderedAt: Date,\n  subject: string,\n  html: string | null,\n  text: string | null,\n  isTransactional: boolean,\n  isHighPriority: boolean,\n  notificationCategoryId: string | null,\n};\n\n// Fields available after sending starts\ntype AdminEmailOutboxStartedSendingFields = AdminEmailOutboxRenderedFields & {\n  startedSendingAt: Date,\n};\n\n// Fields available after delivery completes\n// Use Omit to properly override hasDelivered from base (inherited through chain)\ntype AdminEmailOutboxFinishedDeliveringFields = Omit<AdminEmailOutboxStartedSendingFields, \"hasDelivered\"> & {\n  hasDelivered: true,\n  deliveredAt: Date,\n};\n\n// =============================== STATUS-SPECIFIC TYPES ===============================\n\n// Use Omit to properly override isPaused from base\nexport type AdminEmailOutboxPaused = Omit<AdminEmailOutboxBase, \"isPaused\"> & {\n  status: \"paused\",\n  simpleStatus: \"in-progress\",\n  isPaused: true,\n};\n\nexport type AdminEmailOutboxPreparing = AdminEmailOutboxBase & {\n  status: \"preparing\",\n  simpleStatus: \"in-progress\",\n};\n\nexport type AdminEmailOutboxRendering = AdminEmailOutboxBase & {\n  status: \"rendering\",\n  simpleStatus: \"in-progress\",\n  startedRenderingAt: Date,\n};\n\nexport type AdminEmailOutboxRenderError = AdminEmailOutboxBase & {\n  status: \"render-error\",\n  simpleStatus: \"error\",\n  startedRenderingAt: Date,\n  renderedAt: Date,\n  renderError: string,\n};\n\nexport type AdminEmailOutboxScheduled = AdminEmailOutboxRenderedFields & {\n  status: \"scheduled\",\n  simpleStatus: \"in-progress\",\n};\n\nexport type AdminEmailOutboxQueued = AdminEmailOutboxRenderedFields & {\n  status: \"queued\",\n  simpleStatus: \"in-progress\",\n};\n\nexport type AdminEmailOutboxSending = AdminEmailOutboxStartedSendingFields & {\n  status: \"sending\",\n  simpleStatus: \"in-progress\",\n};\n\nexport type AdminEmailOutboxServerError = AdminEmailOutboxStartedSendingFields & {\n  status: \"server-error\",\n  simpleStatus: \"error\",\n  errorAt: Date,\n  serverError: string,\n};\n\n// SKIPPED can happen at any time, so rendering/sending fields are optional\n// Use Omit to properly override hasRendered from base (can be true or false when skipped)\nexport type AdminEmailOutboxSkipped = Omit<AdminEmailOutboxBase, \"hasRendered\"> & {\n  status: \"skipped\",\n  simpleStatus: \"ok\",\n  hasRendered: boolean,\n  skippedAt: Date,\n  skippedReason: string,\n  skippedDetails: Record<string, unknown>,\n  // Optional fields depending on when skipped\n  startedRenderingAt?: Date,\n  renderedAt?: Date,\n  subject?: string,\n  html?: string | null,\n  text?: string | null,\n  isTransactional?: boolean,\n  isHighPriority?: boolean,\n  notificationCategoryId?: string | null,\n  startedSendingAt?: Date,\n};\n\nexport type AdminEmailOutboxBounced = AdminEmailOutboxStartedSendingFields & {\n  status: \"bounced\",\n  simpleStatus: \"error\",\n  bouncedAt: Date,\n};\n\nexport type AdminEmailOutboxDeliveryDelayed = AdminEmailOutboxStartedSendingFields & {\n  status: \"delivery-delayed\",\n  simpleStatus: \"ok\",\n  deliveryDelayedAt: Date,\n};\n\nexport type AdminEmailOutboxSent = AdminEmailOutboxFinishedDeliveringFields & {\n  status: \"sent\",\n  simpleStatus: \"ok\",\n  canHaveDeliveryInfo: boolean,\n};\n\nexport type AdminEmailOutboxOpened = AdminEmailOutboxFinishedDeliveringFields & {\n  status: \"opened\",\n  simpleStatus: \"ok\",\n  openedAt: Date,\n  canHaveDeliveryInfo: true,\n};\n\nexport type AdminEmailOutboxClicked = AdminEmailOutboxFinishedDeliveringFields & {\n  status: \"clicked\",\n  simpleStatus: \"ok\",\n  clickedAt: Date,\n  canHaveDeliveryInfo: true,\n};\n\nexport type AdminEmailOutboxMarkedAsSpam = AdminEmailOutboxFinishedDeliveringFields & {\n  status: \"marked-as-spam\",\n  simpleStatus: \"ok\",\n  markedAsSpamAt: Date,\n  canHaveDeliveryInfo: true,\n};\n\n// =============================== DISCRIMINATED UNION ===============================\n\nexport type AdminEmailOutbox =\n  | AdminEmailOutboxPaused\n  | AdminEmailOutboxPreparing\n  | AdminEmailOutboxRendering\n  | AdminEmailOutboxRenderError\n  | AdminEmailOutboxScheduled\n  | AdminEmailOutboxQueued\n  | AdminEmailOutboxSending\n  | AdminEmailOutboxServerError\n  | AdminEmailOutboxSkipped\n  | AdminEmailOutboxBounced\n  | AdminEmailOutboxDeliveryDelayed\n  | AdminEmailOutboxSent\n  | AdminEmailOutboxOpened\n  | AdminEmailOutboxClicked\n  | AdminEmailOutboxMarkedAsSpam;\n\ntype SendEmailOptionsBase = {\n  themeId?: string | null | false,\n  subject?: string,\n  notificationCategoryName?: string,\n}\n\n\nexport type SendEmailOptions = SendEmailOptionsBase\n  & XOR<[\n    { userIds: string[] },\n    { allUsers: true }\n  ]>\n  & XOR<[\n    { html: string },\n    {\n      templateId: string,\n      variables?: Record<string, any>,\n    },\n    { draftId: string }\n  ]>\n\nexport type EmailDeliveryWindowStats = {\n  sent: number,\n  bounced: number,\n  marked_as_spam: number,\n};\n\nexport type EmailDeliveryStats = {\n  hour: EmailDeliveryWindowStats,\n  day: EmailDeliveryWindowStats,\n  week: EmailDeliveryWindowStats,\n  month: EmailDeliveryWindowStats,\n};\n\nexport type EmailDeliveryCapacity = {\n  rate_per_second: number,\n  penalty_factor: number,\n};\n\nexport type EmailDeliveryInfo = {\n  stats: EmailDeliveryStats,\n  capacity: EmailDeliveryCapacity,\n};\n"
  },
  {
    "path": "index.ts",
    "content": "export {\n  StackAdminApp, StackClientApp,\n  StackServerApp\n} from \"./apps\";\nexport type {\n  StackAdminAppConstructor,\n  StackAdminAppConstructorOptions,\n  StackClientAppConstructor,\n  StackClientAppConstructorOptions,\n  StackClientAppJson,\n  StackServerAppConstructor,\n  StackServerAppConstructorOptions\n} from \"./apps\";\n\nexport type {\n  EmailOutboxListOptions,\n  EmailOutboxListResult,\n  EmailOutboxUpdateOptions\n} from \"./apps/interfaces/admin-app\";\n\nexport type {\n  ProjectConfig\n} from \"./project-configs\";\n\nexport type {\n  InternalApiKey,\n  InternalApiKeyBase,\n  InternalApiKeyBaseCrudRead,\n  InternalApiKeyCreateOptions,\n  InternalApiKeyFirstView\n} from \"./internal-api-keys\";\n\nexport {\n  stackAppInternalsSymbol\n} from \"./common\";\nexport type {\n  GetCurrentUserOptions,\n  /** @deprecated Use GetCurrentUserOptions instead */\n  GetCurrentUserOptions as GetUserOptions,\n  HandlerUrls,\n  OAuthScopesOnSignIn\n} from \"./common\";\n\nexport type {\n  Connection,\n  OAuthConnection\n} from \"./connected-accounts\";\n\nexport type {\n  ContactChannel,\n  ServerContactChannel\n} from \"./contact-channels\";\n\nexport type {\n  AdminEmailOutbox,\n  AdminEmailOutboxRecipient,\n  AdminEmailOutboxSimpleStatus,\n  AdminEmailOutboxStatus,\n  AdminSendAttemptError,\n  AdminSentEmail\n} from \"./email\";\n\nexport type {\n  AdminProjectPermission,\n  AdminProjectPermissionDefinition,\n  AdminProjectPermissionDefinitionCreateOptions,\n  AdminProjectPermissionDefinitionUpdateOptions, AdminTeamPermission,\n  AdminTeamPermissionDefinition,\n  AdminTeamPermissionDefinitionCreateOptions,\n  AdminTeamPermissionDefinitionUpdateOptions\n} from \"./permissions\";\n\nexport type {\n  AdminDomainConfig,\n  AdminEmailConfig,\n  AdminOAuthProviderConfig,\n  AdminProjectConfig,\n  AdminProjectConfigUpdateOptions,\n  OAuthProviderConfig\n} from \"./project-configs\";\n\nexport type {\n  AdminOwnedProject,\n  AdminProject,\n  AdminProjectCreateOptions,\n  AdminProjectUpdateOptions,\n  Project,\n  PushedConfigSource\n} from \"./projects\";\n\nexport type {\n  EditableTeamMemberProfile,\n  ServerListUsersOptions,\n  ServerTeam,\n  ServerTeamCreateOptions,\n  ReceivedTeamInvitation,\n  SentTeamInvitation,\n  ServerTeamMemberProfile,\n  ServerTeamUpdateOptions,\n  ServerTeamUser,\n  Team,\n  TeamCreateOptions,\n  TeamInvitation,\n  TeamMemberProfile,\n  TeamUpdateOptions,\n  TeamUser\n} from \"./teams\";\n\nexport type {\n  Auth,\n  CurrentInternalServerUser,\n  CurrentInternalUser,\n  CurrentServerUser,\n  CurrentUser,\n  OAuthProvider,\n  ServerOAuthProvider,\n  ServerUser,\n  User\n} from \"./users\";\n\n"
  },
  {
    "path": "internal-api-keys/index.ts",
    "content": "\nimport { InternalApiKeyCreateCrudRequest } from \"@stackframe/stack-shared/dist/interface/admin-interface\";\nimport { InternalApiKeysCrud } from \"@stackframe/stack-shared/dist/interface/crud/internal-api-keys\";\n\nexport type InternalApiKeyBase = {\n  id: string,\n  description: string,\n  expiresAt: Date,\n  manuallyRevokedAt: Date | null,\n  createdAt: Date,\n  isValid(): boolean,\n  whyInvalid(): \"expired\" | \"manually-revoked\" | null,\n  revoke(): Promise<void>,\n};\n\nexport type InternalApiKeyBaseCrudRead = Pick<InternalApiKeysCrud[\"Admin\"][\"Read\"], \"id\" | \"created_at_millis\" | \"description\" | \"expires_at_millis\" | \"manually_revoked_at_millis\">;\n\nexport type InternalApiKeyFirstView = {\n  publishableClientKey?: string,\n  secretServerKey?: string,\n  superSecretAdminKey?: string,\n} & InternalApiKeyBase;\n\nexport type InternalApiKey = {\n  publishableClientKey: null | {\n    lastFour: string,\n  },\n  secretServerKey: null | {\n    lastFour: string,\n  },\n  superSecretAdminKey: null | {\n    lastFour: string,\n  },\n} & InternalApiKeyBase;\n\nexport type InternalApiKeyCreateOptions = {\n  description: string,\n  expiresAt: Date,\n  hasPublishableClientKey: boolean,\n  hasSecretServerKey: boolean,\n  hasSuperSecretAdminKey: boolean,\n};\nexport function internalApiKeyCreateOptionsToCrud(options: InternalApiKeyCreateOptions): InternalApiKeyCreateCrudRequest {\n  return {\n    description: options.description,\n    expires_at_millis: options.expiresAt.getTime(),\n    has_publishable_client_key: options.hasPublishableClientKey,\n    has_secret_server_key: options.hasSecretServerKey,\n    has_super_secret_admin_key: options.hasSuperSecretAdminKey,\n  };\n}\n"
  },
  {
    "path": "notification-categories/index.ts",
    "content": "export type NotificationCategory = {\n  id: string,\n  name: string,\n  enabled: boolean,\n  canDisable: boolean,\n\n  setEnabled(enabled: boolean): Promise<void>,\n}\n"
  },
  {
    "path": "permissions/index.ts",
    "content": "import { ProjectPermissionDefinitionsCrud } from \"@stackframe/stack-shared/dist/interface/crud/project-permissions\";\nimport { TeamPermissionDefinitionsCrud } from \"@stackframe/stack-shared/dist/interface/crud/team-permissions\";\n\n\nexport type TeamPermission = {\n  id: string,\n};\n\nexport type AdminTeamPermission = TeamPermission;\n\nexport type AdminTeamPermissionDefinition = {\n  id: string,\n  description?: string,\n  containedPermissionIds: string[],\n  isDefaultUserPermission?: boolean,\n};\n\nexport type AdminTeamPermissionDefinitionCreateOptions = {\n  id: string,\n  description?: string,\n  containedPermissionIds: string[],\n  isDefaultUserPermission?: boolean,\n};\nexport function adminTeamPermissionDefinitionCreateOptionsToCrud(options: AdminTeamPermissionDefinitionCreateOptions): TeamPermissionDefinitionsCrud[\"Admin\"][\"Create\"] {\n  return {\n    id: options.id,\n    description: options.description,\n    contained_permission_ids: options.containedPermissionIds,\n  };\n}\n\nexport type AdminTeamPermissionDefinitionUpdateOptions = Pick<Partial<AdminTeamPermissionDefinitionCreateOptions>, \"description\" | \"containedPermissionIds\">;\nexport function adminTeamPermissionDefinitionUpdateOptionsToCrud(options: AdminTeamPermissionDefinitionUpdateOptions): TeamPermissionDefinitionsCrud[\"Admin\"][\"Update\"] {\n  return {\n    description: options.description,\n    contained_permission_ids: options.containedPermissionIds,\n  };\n}\n\nexport type ProjectPermission = {\n  id: string,\n};\n\nexport type AdminProjectPermission = ProjectPermission;\n\nexport type AdminProjectPermissionDefinition = {\n  id: string,\n  description?: string,\n  containedPermissionIds: string[],\n};\n\nexport type AdminProjectPermissionDefinitionCreateOptions = {\n  id: string,\n  description?: string,\n  containedPermissionIds: string[],\n};\nexport function adminProjectPermissionDefinitionCreateOptionsToCrud(options: AdminProjectPermissionDefinitionCreateOptions): ProjectPermissionDefinitionsCrud[\"Admin\"][\"Create\"] {\n  return {\n    id: options.id,\n    description: options.description,\n    contained_permission_ids: options.containedPermissionIds,\n  };\n}\n\nexport type AdminProjectPermissionDefinitionUpdateOptions = Pick<Partial<AdminProjectPermissionDefinitionCreateOptions>, \"description\" | \"containedPermissionIds\">;\nexport function adminProjectPermissionDefinitionUpdateOptionsToCrud(options: AdminProjectPermissionDefinitionUpdateOptions): ProjectPermissionDefinitionsCrud[\"Admin\"][\"Update\"] {\n  return {\n    description: options.description,\n    contained_permission_ids: options.containedPermissionIds,\n  };\n}\n"
  },
  {
    "path": "project-configs/index.ts",
    "content": "import { AdminTeamPermission } from \"../permissions\";\n\nexport type ProjectConfig = {\n  readonly signUpEnabled: boolean,\n  readonly credentialEnabled: boolean,\n  readonly magicLinkEnabled: boolean,\n  readonly passkeyEnabled: boolean,\n  readonly clientTeamCreationEnabled: boolean,\n  readonly clientUserDeletionEnabled: boolean,\n  readonly oauthProviders: OAuthProviderConfig[],\n  readonly allowUserApiKeys: boolean,\n  readonly allowTeamApiKeys: boolean,\n};\n\nexport type OAuthProviderConfig = {\n  readonly id: string,\n};\n\n/**\n * @deprecated This type is deprecated. Use the new config override setup instead.\n */\nexport type AdminProjectConfig = {\n  readonly signUpEnabled: boolean,\n  readonly credentialEnabled: boolean,\n  readonly magicLinkEnabled: boolean,\n  readonly passkeyEnabled: boolean,\n  readonly clientTeamCreationEnabled: boolean,\n  readonly clientUserDeletionEnabled: boolean,\n  readonly allowLocalhost: boolean,\n  readonly oauthProviders: AdminOAuthProviderConfig[],\n  readonly emailConfig?: AdminEmailConfig,\n  readonly emailTheme: string,\n  readonly domains: AdminDomainConfig[],\n  readonly createTeamOnSignUp: boolean,\n  readonly teamCreatorDefaultPermissions: AdminTeamPermission[],\n  readonly teamMemberDefaultPermissions: AdminTeamPermission[],\n  readonly userDefaultPermissions: AdminTeamPermission[],\n  readonly oauthAccountMergeStrategy: 'link_method' | 'raise_error' | 'allow_duplicates',\n  readonly allowUserApiKeys: boolean,\n  readonly allowTeamApiKeys: boolean,\n};\n\nexport type AdminEmailConfig = (\n  {\n    type: \"standard\" | \"resend\",\n    senderName: string,\n    senderEmail: string,\n    host: string,\n    port: number,\n    username: string,\n    password: string,\n  }\n  | {\n    type: \"shared\",\n  }\n);\n\nexport type AdminDomainConfig = {\n  domain: string,\n  handlerPath: string,\n};\n\nexport type AdminOAuthProviderConfig = {\n  id: string,\n} & (\n    | { type: 'shared' }\n    | {\n      type: 'standard',\n      clientId: string,\n      clientSecret: string,\n      facebookConfigId?: string,\n      microsoftTenantId?: string,\n      appleBundleIds?: string[],\n    }\n  ) & OAuthProviderConfig;\n\nexport type AdminProjectConfigUpdateOptions = {\n  domains?: {\n    domain: string,\n    handlerPath: string,\n  }[],\n  oauthProviders?: AdminOAuthProviderConfig[],\n  signUpEnabled?: boolean,\n  credentialEnabled?: boolean,\n  magicLinkEnabled?: boolean,\n  passkeyEnabled?: boolean,\n  clientTeamCreationEnabled?: boolean,\n  clientUserDeletionEnabled?: boolean,\n  allowLocalhost?: boolean,\n  createTeamOnSignUp?: boolean,\n  emailConfig?: AdminEmailConfig,\n  emailTheme?: string,\n  teamCreatorDefaultPermissions?: { id: string }[],\n  teamMemberDefaultPermissions?: { id: string }[],\n  userDefaultPermissions?: { id: string }[],\n  oauthAccountMergeStrategy?: 'link_method' | 'raise_error' | 'allow_duplicates',\n  allowUserApiKeys?: boolean,\n  allowTeamApiKeys?: boolean,\n};\n"
  },
  {
    "path": "projects/index.ts",
    "content": "import { ProductionModeError } from \"@stackframe/stack-shared/dist/helpers/production-mode\";\nimport { AdminUserProjectsCrud, ProjectsCrud } from \"@stackframe/stack-shared/dist/interface/crud/projects\";\n\nimport { CompleteConfig, EnvironmentConfigNormalizedOverride, EnvironmentConfigOverrideOverride } from \"@stackframe/stack-shared/dist/config/schema\";\nimport { StackAdminApp } from \"../apps/interfaces/admin-app\";\nimport { AdminProjectConfig, AdminProjectConfigUpdateOptions, ProjectConfig } from \"../project-configs\";\n\n/**\n * SDK type for pushed config source (camelCase for SDK).\n * Represents where the branch config was pushed from.\n */\nexport type PushedConfigSource =\n  | { type: \"pushed-from-github\", owner: string, repo: string, branch: string, commitHash: string, configFilePath: string }\n  | { type: \"pushed-from-unknown\" }\n  | { type: \"unlinked\" };\n\nexport type PushConfigOptions = {\n  /**\n   * The source of this config push.\n   */\n  source: PushedConfigSource,\n};\n\n\nexport type Project = {\n  readonly id: string,\n  readonly displayName: string,\n  readonly config: ProjectConfig,\n};\n\nexport type AdminProject = {\n  readonly id: string,\n  readonly displayName: string,\n  readonly description: string | null,\n  readonly createdAt: Date,\n  readonly isProductionMode: boolean,\n  readonly ownerTeamId: string | null,\n  readonly logoUrl: string | null | undefined,\n  readonly logoFullUrl: string | null | undefined,\n  readonly logoDarkModeUrl: string | null | undefined,\n  readonly logoFullDarkModeUrl: string | null | undefined,\n\n  readonly config: AdminProjectConfig,\n\n  update(this: AdminProject, update: AdminProjectUpdateOptions): Promise<void>,\n  delete(this: AdminProject): Promise<void>,\n\n  getConfig(this: AdminProject): Promise<CompleteConfig>,\n  // NEXT_LINE_PLATFORM react-like\n  useConfig(this: AdminProject): CompleteConfig,\n\n  /**\n   * Updates the environment's config by merging the provided config into the existing config.\n   *\n   * Changes made with `updateConfig` always take precedence over those made with `pushConfig`, even if the `pushConfig`\n   * config was pushed after the changes were made with `updateConfig`. This is best for environment-specific\n   * configuration like secrets, API keys, and other values that you wouldn't push into a source repository.\n   */\n  // We have some strict types here in order to prevent accidental overwriting of a top-level property of a config object\n  updateConfig(\n    this: AdminProject,\n    config: EnvironmentConfigOverrideOverride,\n  ): Promise<void>,\n\n  /**\n   * Pushes a config, replacing any previous config pushed with `pushConfig`.\n   *\n   * **Note:** This function does **not** replace any changes made with `updateConfig`. Changes made with\n   * `updateConfig` always take precedence over those made with `pushConfig`, even if the `pushConfig`\n   * config was pushed after the changes were made with `updateConfig`.\n   *\n   * This is useful for programmatically deploying configuration. More often than not, you'll want to use\n   * `updateConfig` instead.\n   */\n  pushConfig(\n    this: AdminProject,\n    config: EnvironmentConfigOverrideOverride,\n    options: PushConfigOptions,\n  ): Promise<void>,\n\n  /**\n   * Updates the pushed config by merging the provided config into the existing pushed config.\n   *\n   * **Warning:** This is almost always **not** the function you want to call. Changes made with\n   * `updatePushedConfig` will be replaced entirely the next time `pushConfig` is called. Consider using\n   * `pushConfig` to set the full pushed config, or `updateConfig` for environment-specific values that\n   * should persist across pushes.\n   *\n   * This function is useful for making temporary modifications to the pushed config before the next push.\n   */\n  updatePushedConfig(\n    this: AdminProject,\n    config: EnvironmentConfigOverrideOverride\n  ): Promise<void>,\n\n  /**\n   * Gets the source metadata for the pushed config, indicating where it was pushed from.\n   *\n   * The source can be:\n   * - `pushed-from-github`: Config was pushed from a GitHub repository\n   * - `pushed-from-unknown`: Config was pushed via CLI but source details unknown\n   * - `unlinked`: Config can be edited directly on the dashboard\n   */\n  getPushedConfigSource(this: AdminProject): Promise<PushedConfigSource>,\n\n  /**\n   * Unlinks the pushed config source, setting it to \"unlinked\".\n   * This allows the config to be edited directly on the dashboard without external push restrictions.\n   */\n  unlinkPushedConfigSource(this: AdminProject): Promise<void>,\n\n  /**\n   * Resets (removes) specific keys from the config override at the specified level.\n   * Uses the same nested key logic as the override algorithm: resetting key \"a.b\" also resets \"a.b.c\".\n   *\n   * This is useful when updating the pushed config (branch level) and wanting to remove the same keys\n   * from the environment config override so that the branch config values take precedence.\n   */\n  resetConfigOverrideKeys(this: AdminProject, level: \"branch\" | \"environment\", keys: string[]): Promise<void>,\n\n  /**\n   * Gets the raw config override at the specified level (before merging/defaults).\n   * Useful for inspecting exactly what's been set at each level.\n   */\n  getConfigOverride(this: AdminProject, level: \"branch\" | \"environment\"): Promise<Record<string, unknown>>,\n\n  /**\n   * Replaces the entire config override at the specified level.\n   * For branch level, preserves the existing source metadata.\n   */\n  replaceConfigOverride(this: AdminProject, level: \"branch\" | \"environment\", config: Record<string, unknown>): Promise<void>,\n\n  getProductionModeErrors(this: AdminProject): Promise<ProductionModeError[]>,\n  // NEXT_LINE_PLATFORM react-like\n  useProductionModeErrors(this: AdminProject): ProductionModeError[],\n} & Project;\n\nexport type AdminOwnedProject = {\n  readonly app: StackAdminApp<false>,\n} & AdminProject;\n\nexport type AdminProjectUpdateOptions = {\n  displayName?: string,\n  description?: string,\n  isProductionMode?: boolean,\n  /**\n   * Updates `project.requirePublishableClientKey` in the project-level config override.\n   */\n  requirePublishableClientKey?: boolean,\n  logoUrl?: string | null,\n  logoFullUrl?: string | null,\n  logoDarkModeUrl?: string | null,\n  logoFullDarkModeUrl?: string | null,\n  config?: AdminProjectConfigUpdateOptions,\n};\nexport function adminProjectUpdateOptionsToCrud(options: AdminProjectUpdateOptions): ProjectsCrud[\"Admin\"][\"Update\"] {\n  return {\n    display_name: options.displayName,\n    description: options.description,\n    is_production_mode: options.isProductionMode,\n    logo_url: options.logoUrl,\n    logo_full_url: options.logoFullUrl,\n    logo_dark_mode_url: options.logoDarkModeUrl,\n    logo_full_dark_mode_url: options.logoFullDarkModeUrl,\n    /**\n     * NOTE: Do not update this config anymore. It's been superseded by the new config in schema.ts.\n     * @deprecated\n     */\n    config: {\n      domains: options.config?.domains?.map((d) => ({\n        domain: d.domain,\n        handler_path: d.handlerPath\n      })),\n      oauth_providers: options.config?.oauthProviders?.map((p) => ({\n        id: p.id as any,\n        type: p.type,\n        ...(p.type === 'standard' && {\n          client_id: p.clientId,\n          client_secret: p.clientSecret,\n          facebook_config_id: p.facebookConfigId,\n          microsoft_tenant_id: p.microsoftTenantId,\n          apple_bundle_ids: p.appleBundleIds,\n        }),\n      })),\n      email_config: options.config?.emailConfig && (\n        options.config.emailConfig.type === 'shared' ? {\n          type: 'shared',\n        } : {\n          type: 'standard',\n          host: options.config.emailConfig.host,\n          port: options.config.emailConfig.port,\n          username: options.config.emailConfig.username,\n          password: options.config.emailConfig.password,\n          sender_name: options.config.emailConfig.senderName,\n          sender_email: options.config.emailConfig.senderEmail,\n        }\n      ),\n      email_theme: options.config?.emailTheme,\n      sign_up_enabled: options.config?.signUpEnabled,\n      credential_enabled: options.config?.credentialEnabled,\n      magic_link_enabled: options.config?.magicLinkEnabled,\n      passkey_enabled: options.config?.passkeyEnabled,\n      allow_localhost: options.config?.allowLocalhost,\n      create_team_on_sign_up: options.config?.createTeamOnSignUp,\n      client_team_creation_enabled: options.config?.clientTeamCreationEnabled,\n      client_user_deletion_enabled: options.config?.clientUserDeletionEnabled,\n      team_creator_default_permissions: options.config?.teamCreatorDefaultPermissions,\n      team_member_default_permissions: options.config?.teamMemberDefaultPermissions,\n      user_default_permissions: options.config?.userDefaultPermissions,\n      oauth_account_merge_strategy: options.config?.oauthAccountMergeStrategy,\n      allow_user_api_keys: options.config?.allowUserApiKeys,\n      allow_team_api_keys: options.config?.allowTeamApiKeys,\n    },\n  };\n}\n\nexport type AdminProjectCreateOptions = Omit<AdminProjectUpdateOptions, 'displayName'> & {\n  displayName: string,\n  teamId: string,\n};\nexport function adminProjectCreateOptionsToCrud(options: AdminProjectCreateOptions): AdminUserProjectsCrud[\"Server\"][\"Create\"] {\n  return {\n    ...adminProjectUpdateOptionsToCrud(options),\n    display_name: options.displayName,\n    owner_team_id: options.teamId,\n  };\n}\n"
  },
  {
    "path": "session-replays/index.ts",
    "content": "export type AdminSessionReplay = {\n  id: string,\n  projectUser: {\n    id: string,\n    displayName: string | null,\n    primaryEmail: string | null,\n  },\n  startedAt: Date,\n  lastEventAt: Date,\n  chunkCount: number,\n  eventCount: number,\n};\n\nexport type AdminSessionReplayChunk = {\n  id: string,\n  batchId: string,\n  sessionReplaySegmentId: string | null,\n  browserSessionId: string | null,\n  eventCount: number,\n  byteLength: number,\n  firstEventAt: Date,\n  lastEventAt: Date,\n  createdAt: Date,\n};\n\nexport type ListSessionReplaysOptions = {\n  limit?: number,\n  cursor?: string,\n};\n\nexport type ListSessionReplaysResult = {\n  items: AdminSessionReplay[],\n  nextCursor: string | null,\n};\n\nexport type ListSessionReplayChunksOptions = {\n  limit?: number,\n  cursor?: string,\n};\n\nexport type ListSessionReplayChunksResult = {\n  items: AdminSessionReplayChunk[],\n  nextCursor: string | null,\n};\n\nexport type SessionReplayAllEventsResult = {\n  chunks: Array<{\n    id: string,\n    batchId: string,\n    sessionReplaySegmentId: string | null,\n    eventCount: number,\n    byteLength: number,\n    firstEventAt: Date,\n    lastEventAt: Date,\n    createdAt: Date,\n  }>,\n  chunkEvents: Array<{\n    chunkId: string,\n    events: unknown[],\n  }>,\n};\n"
  },
  {
    "path": "teams/index.ts",
    "content": "import { TeamsCrud } from \"@stackframe/stack-shared/dist/interface/crud/teams\";\nimport { ReadonlyJson } from \"@stackframe/stack-shared/dist/utils/json\";\n\nimport { ApiKeyCreationOptions, TeamApiKey, TeamApiKeyFirstView } from \"../api-keys\";\nimport { AsyncStoreProperty } from \"../common\";\nimport { Customer } from \"../customers\";\nimport { ServerUser } from \"../users\";\n\n\nexport type TeamMemberProfile = {\n  displayName: string | null,\n  profileImageUrl: string | null,\n}\n\nexport type TeamMemberProfileUpdateOptions = {\n  displayName?: string,\n  profileImageUrl?: string | null,\n};\n\nexport type EditableTeamMemberProfile = TeamMemberProfile & {\n  update(update: TeamMemberProfileUpdateOptions): Promise<void>,\n}\n\nexport type TeamUser = {\n  id: string,\n  teamProfile: TeamMemberProfile,\n}\n\n/**\n * A team invitation as seen from the team's perspective (ie. the sender).\n *\n * Returned by `team.listInvitations()`. Contains the recipient email and allows\n * revoking the invitation.\n */\nexport type SentTeamInvitation = {\n  id: string,\n  recipientEmail: string | null,\n  expiresAt: Date,\n  revoke(): Promise<void>,\n}\n\n/**\n * @deprecated Use `SentTeamInvitation` instead.\n */\nexport type TeamInvitation = SentTeamInvitation;\n\n/**\n * A team invitation as seen from the invited user's perspective (ie. the receiver).\n *\n * Returned by `user.listTeamInvitations()`. Contains information about teams that have\n * sent invitations to any of the user's verified email addresses, and allows accepting\n * the invitation to join the team.\n */\nexport type ReceivedTeamInvitation = {\n  id: string,\n  teamId: string,\n  teamDisplayName: string,\n  recipientEmail: string,\n  expiresAt: Date,\n\n  /**\n   * Accepts the invitation, adding the current user to the team.\n   *\n   * The user must have a verified email address matching the invitation's recipient email.\n   */\n  accept(): Promise<void>,\n}\n\nexport type Team = {\n  id: string,\n  displayName: string,\n  profileImageUrl: string | null,\n  clientMetadata: any,\n  clientReadOnlyMetadata: any,\n  inviteUser(options: { email: string, callbackUrl?: string }): Promise<void>,\n  listUsers(): Promise<TeamUser[]>,\n  useUsers(): TeamUser[], // THIS_LINE_PLATFORM react-like\n  listInvitations(): Promise<SentTeamInvitation[]>,\n  useInvitations(): SentTeamInvitation[], // THIS_LINE_PLATFORM react-like\n  update(update: TeamUpdateOptions): Promise<void>,\n  delete(): Promise<void>,\n  createApiKey(options: ApiKeyCreationOptions<\"team\">): Promise<TeamApiKeyFirstView>,\n} & AsyncStoreProperty<\"apiKeys\", [], TeamApiKey[], true> & Customer;\n\nexport type TeamUpdateOptions = {\n  displayName?: string,\n  profileImageUrl?: string | null,\n  clientMetadata?: ReadonlyJson,\n};\nexport function teamUpdateOptionsToCrud(options: TeamUpdateOptions): TeamsCrud[\"Client\"][\"Update\"] {\n  return {\n    display_name: options.displayName,\n    profile_image_url: options.profileImageUrl,\n    client_metadata: options.clientMetadata,\n  };\n}\n\nexport type TeamCreateOptions = {\n  displayName: string,\n  profileImageUrl?: string,\n}\nexport function teamCreateOptionsToCrud(options: TeamCreateOptions, creatorUserId: string): TeamsCrud[\"Client\"][\"Create\"] {\n  return {\n    display_name: options.displayName,\n    profile_image_url: options.profileImageUrl,\n    creator_user_id: creatorUserId,\n  };\n}\n\n\nexport type ServerTeamMemberProfile = TeamMemberProfile;\n\nexport type ServerTeamUser = ServerUser & {\n  teamProfile: ServerTeamMemberProfile,\n}\n\nexport type ServerTeam = {\n  createdAt: Date,\n  serverMetadata: any,\n  listUsers(): Promise<ServerTeamUser[]>,\n  useUsers(): ServerUser[], // THIS_LINE_PLATFORM react-like\n  update(update: ServerTeamUpdateOptions): Promise<void>,\n  delete(): Promise<void>,\n  addUser(userId: string): Promise<void>,\n  inviteUser(options: { email: string, callbackUrl?: string }): Promise<void>,\n  removeUser(userId: string): Promise<void>,\n} & Team;\n\nexport type ServerListUsersOptions = {\n  cursor?: string,\n  limit?: number,\n  orderBy?: 'signedUpAt',\n  desc?: boolean,\n  query?: string,\n  /**\n   * Whether to include restricted users (users who haven't completed onboarding requirements).\n   * Defaults to false.\n   */\n  includeRestricted?: boolean,\n  /**\n   * Whether to include anonymous users (and restricted users).\n   * Defaults to false.\n   */\n  includeAnonymous?: boolean,\n};\n\nexport type ServerTeamCreateOptions = TeamCreateOptions & {\n  creatorUserId?: string,\n};\nexport function serverTeamCreateOptionsToCrud(options: ServerTeamCreateOptions): TeamsCrud[\"Server\"][\"Create\"] {\n  return {\n    display_name: options.displayName,\n    profile_image_url: options.profileImageUrl,\n    creator_user_id: options.creatorUserId,\n  };\n}\n\nexport type ServerTeamUpdateOptions = TeamUpdateOptions & {\n  clientReadOnlyMetadata?: ReadonlyJson,\n  serverMetadata?: ReadonlyJson,\n};\nexport function serverTeamUpdateOptionsToCrud(options: ServerTeamUpdateOptions): TeamsCrud[\"Server\"][\"Update\"] {\n  return {\n    display_name: options.displayName,\n    profile_image_url: options.profileImageUrl,\n    client_metadata: options.clientMetadata,\n    client_read_only_metadata: options.clientReadOnlyMetadata,\n    server_metadata: options.serverMetadata,\n  };\n}\n"
  },
  {
    "path": "users/index.ts",
    "content": "import { KnownErrors } from \"@stackframe/stack-shared\";\nimport { CurrentUserCrud } from \"@stackframe/stack-shared/dist/interface/crud/current-user\";\nimport { UsersCrud } from \"@stackframe/stack-shared/dist/interface/crud/users\";\nimport type { RestrictedReason } from \"@stackframe/stack-shared/dist/schema-fields\";\nimport { InternalSession } from \"@stackframe/stack-shared/dist/sessions\";\nimport { encodeBase64 } from \"@stackframe/stack-shared/dist/utils/bytes\";\nimport { GeoInfo } from \"@stackframe/stack-shared/dist/utils/geo\";\nimport { ReadonlyJson } from \"@stackframe/stack-shared/dist/utils/json\";\nimport { ProviderType } from \"@stackframe/stack-shared/dist/utils/oauth\";\nimport { Result } from \"@stackframe/stack-shared/dist/utils/results\";\nimport { ApiKeyCreationOptions, UserApiKey, UserApiKeyFirstView } from \"../api-keys\";\nimport { AsyncStoreProperty, AuthLike } from \"../common\";\nimport { DeprecatedOAuthConnection, OAuthConnection } from \"../connected-accounts\";\nimport { ContactChannel, ContactChannelCreateOptions, ServerContactChannel, ServerContactChannelCreateOptions } from \"../contact-channels\";\nimport { Customer } from \"../customers\";\nimport { NotificationCategory } from \"../notification-categories\";\nimport { AdminTeamPermission, TeamPermission } from \"../permissions\";\nimport { AdminOwnedProject, AdminProjectCreateOptions } from \"../projects\";\nimport { EditableTeamMemberProfile, ReceivedTeamInvitation, ServerTeam, ServerTeamCreateOptions, Team, TeamCreateOptions } from \"../teams\";\n\nconst userGetterErrorMessage = \"Stack Auth: useUser() already returns the user object. Use `const user = useUser()` (or `const user = await app.getUser()`) instead of destructuring it like `const { user } = ...`.\";\n\nexport function withUserDestructureGuard<T extends object>(target: T): T {\n  Object.freeze(target);\n  return new Proxy(target, {\n    get(target, prop, receiver) {\n      if (prop === \"user\") {\n        return guardGetter();\n      }\n      return target[prop as keyof T];\n    },\n  });\n}\n\nfunction guardGetter(): never {\n  throw new Error(userGetterErrorMessage);\n}\n\nexport type OAuthProvider = {\n  readonly id: string,\n  readonly type: string,\n  readonly userId: string,\n  readonly accountId?: string,\n  readonly email?: string,\n  readonly allowSignIn: boolean,\n  readonly allowConnectedAccounts: boolean,\n  update(data: { allowSignIn?: boolean, allowConnectedAccounts?: boolean }): Promise<Result<void,\n    InstanceType<typeof KnownErrors.OAuthProviderAccountIdAlreadyUsedForSignIn>\n  >>,\n  delete(): Promise<void>,\n};\n\nexport type ServerOAuthProvider = {\n  readonly id: string,\n  readonly type: string,\n  readonly userId: string,\n  readonly accountId: string,\n  readonly email?: string,\n  readonly allowSignIn: boolean,\n  readonly allowConnectedAccounts: boolean,\n  update(data: { accountId?: string, email?: string, allowSignIn?: boolean, allowConnectedAccounts?: boolean }): Promise<Result<void,\n    InstanceType<typeof KnownErrors.OAuthProviderAccountIdAlreadyUsedForSignIn>\n  >>,\n  delete(): Promise<void>,\n};\n\n\n/**\n * Contains everything related to the current user session.\n */\nexport type Auth = AuthLike<{}> & {\n  readonly _internalSession: InternalSession,\n  readonly currentSession: {\n    getTokens(): Promise<{ accessToken: string | null, refreshToken: string | null }>,\n    useTokens(): { accessToken: string | null, refreshToken: string | null }, // THIS_LINE_PLATFORM react-like\n  },\n};\n\n/**\n * ```\n * +----------+-------------+-------------------+\n * |    \\     |   !Server   |      Server       |\n * +----------+-------------+-------------------+\n * | !Session | User        | ServerUser        |\n * | Session  | CurrentUser | CurrentServerUser |\n * +----------+-------------+-------------------+\n * ```\n *\n * The fields on each of these types are available iff:\n * BaseUser: true\n * Auth: Session\n * ServerBaseUser: Server\n * UserExtra: Session OR Server\n *\n * The types are defined as follows (in the typescript manner):\n * User = BaseUser\n * CurrentUser = BaseUser & Auth & UserExtra\n * ServerUser = BaseUser & ServerBaseUser & UserExtra\n * CurrentServerUser = BaseUser & ServerBaseUser & Auth & UserExtra\n **/\n\nexport type BaseUser = {\n  readonly id: string,\n\n  readonly displayName: string | null,\n\n  /**\n   * The user's email address.\n   *\n   * Note: This might NOT be unique across multiple users, so always use `id` for unique identification.\n   */\n  readonly primaryEmail: string | null,\n  readonly primaryEmailVerified: boolean,\n  readonly profileImageUrl: string | null,\n\n  readonly signedUpAt: Date,\n\n  readonly clientMetadata: any,\n  readonly clientReadOnlyMetadata: any,\n\n  /**\n   * Whether the user has a password set.\n   */\n  readonly hasPassword: boolean,\n  readonly otpAuthEnabled: boolean,\n  readonly passkeyAuthEnabled: boolean,\n\n  readonly isMultiFactorRequired: boolean,\n  readonly isAnonymous: boolean,\n  /**\n   * Whether the user is in restricted state (signed up but hasn't completed onboarding requirements).\n   * For example, if email verification is required but the user hasn't verified their email yet.\n   */\n  readonly isRestricted: boolean,\n  /**\n   * The reason why the user is restricted, e.g., { type: \"email_not_verified\" }, { type: \"anonymous\" }, or { type: \"restricted_by_administrator\" }.\n   * Null if the user is not restricted.\n   */\n  readonly restrictedReason: RestrictedReason | null,\n  toClientJson(): CurrentUserCrud[\"Client\"][\"Read\"],\n\n  /**\n   * @deprecated, use contact channel's usedForAuth instead\n   */\n  readonly emailAuthEnabled: boolean,\n  /**\n   * @deprecated\n   */\n  readonly oauthProviders: readonly { id: string }[],\n}\n\nexport type UserExtra = {\n  setDisplayName(displayName: string | null): Promise<void>,\n  /** @deprecated Use contact channel's sendVerificationEmail instead */\n  sendVerificationEmail(): Promise<KnownErrors[\"EmailAlreadyVerified\"] | void>,\n  setClientMetadata(metadata: any): Promise<void>,\n  updatePassword(options: { oldPassword: string, newPassword: string}): Promise<KnownErrors[\"PasswordConfirmationMismatch\"] | KnownErrors[\"PasswordRequirementsNotMet\"] | void>,\n  setPassword(options: { password: string }): Promise<KnownErrors[\"PasswordRequirementsNotMet\"] | void>,\n\n  /**\n   * A shorthand method to update multiple fields of the user at once.\n   */\n  update(update: UserUpdateOptions): Promise<void>,\n\n  useContactChannels(): ContactChannel[], // THIS_LINE_PLATFORM react-like\n  listContactChannels(): Promise<ContactChannel[]>,\n  createContactChannel(data: ContactChannelCreateOptions): Promise<ContactChannel>,\n\n  useNotificationCategories(): NotificationCategory[], // THIS_LINE_PLATFORM react-like\n  listNotificationCategories(): Promise<NotificationCategory[]>,\n\n  delete(): Promise<void>,\n\n  /** @deprecated Use `getOrLinkConnectedAccount` for redirect behavior, or `getConnectedAccount({ provider, providerAccountId })` for existence check. */\n  getConnectedAccount(id: ProviderType, options: { or: 'redirect', scopes?: string[] }): Promise<DeprecatedOAuthConnection>,\n  /** @deprecated Use `getConnectedAccount({ provider, providerAccountId })` for existence check, or `getOrLinkConnectedAccount` for redirect behavior. */\n  getConnectedAccount(id: ProviderType, options?: { or?: 'redirect' | 'throw' | 'return-null', scopes?: string[] }): Promise<DeprecatedOAuthConnection | null>,\n  /** Get a specific connected account by provider and providerAccountId. Returns null if not found. */\n  getConnectedAccount(account: { provider: string, providerAccountId: string }): Promise<OAuthConnection | null>,\n\n  // IF_PLATFORM react-like\n  /** @deprecated Use `useOrLinkConnectedAccount` for redirect behavior, or `useConnectedAccount({ provider, providerAccountId })` for existence check. */\n  useConnectedAccount(id: ProviderType, options: { or: 'redirect', scopes?: string[] }): DeprecatedOAuthConnection,\n  /** @deprecated Use `useConnectedAccount({ provider, providerAccountId })` for existence check, or `useOrLinkConnectedAccount` for redirect behavior. */\n  useConnectedAccount(id: ProviderType, options?: { or?: 'redirect' | 'throw' | 'return-null', scopes?: string[] }): DeprecatedOAuthConnection | null,\n  /** Get a specific connected account by provider and providerAccountId. Returns null if not found. */\n  useConnectedAccount(account: { provider: string, providerAccountId: string }): OAuthConnection | null,\n  // END_PLATFORM\n\n  /** List all connected accounts for this user (only those with allowConnectedAccounts enabled). */\n  listConnectedAccounts(): Promise<OAuthConnection[]>,\n  /** React hook to list all connected accounts. */\n  useConnectedAccounts(): OAuthConnection[], // THIS_LINE_PLATFORM react-like\n  /** Redirect the user to the OAuth flow to link a new connected account. Always redirects, never returns. */\n  linkConnectedAccount(provider: string, options?: { scopes?: string[] }): Promise<void>,\n  /** Get a connected account for the given provider, or redirect to link one if none exists or the token/scopes are insufficient. */\n  getOrLinkConnectedAccount(provider: string, options?: { scopes?: string[] }): Promise<OAuthConnection>,\n  /** React hook: get a connected account for the given provider, or redirect to link one if none exists or the token/scopes are insufficient. */\n  useOrLinkConnectedAccount(provider: string, options?: { scopes?: string[] }): OAuthConnection, // THIS_LINE_PLATFORM react-like\n\n  hasPermission(scope: Team, permissionId: string): Promise<boolean>,\n  hasPermission(permissionId: string): Promise<boolean>,\n\n  getPermission(scope: Team, permissionId: string): Promise<TeamPermission | null>,\n  getPermission(permissionId: string): Promise<TeamPermission | null>,\n\n  listPermissions(scope: Team, options?: { recursive?: boolean }): Promise<TeamPermission[]>,\n  listPermissions(options?: { recursive?: boolean }): Promise<TeamPermission[]>,\n\n  // IF_PLATFORM react-like\n  usePermissions(scope: Team, options?: { recursive?: boolean }): TeamPermission[],\n  usePermissions(options?: { recursive?: boolean }): TeamPermission[],\n\n  usePermission(scope: Team, permissionId: string): TeamPermission | null,\n  usePermission(permissionId: string): TeamPermission | null,\n  // END_PLATFORM\n\n  readonly selectedTeam: Team | null,\n  setSelectedTeam(teamOrId: string | Team | null): Promise<void>,\n  createTeam(data: TeamCreateOptions): Promise<Team>,\n  leaveTeam(team: Team): Promise<void>,\n\n  /**\n   * Lists all pending team invitations sent to any of the current user's verified email addresses.\n   *\n   * This allows the user to discover which teams have invited them, even if they haven't\n   * joined those teams yet. Only invitations sent to verified email addresses are included.\n   *\n   * @returns An array of `ReceivedTeamInvitation` objects, each containing the team ID, team\n   * display name, recipient email, and expiration date.\n   *\n   * @example\n   * ```ts\n   * const invitations = await user.listTeamInvitations();\n   * for (const invitation of invitations) {\n   *   console.log(`Invited to ${invitation.teamDisplayName} via ${invitation.recipientEmail}`);\n   * }\n   * ```\n   */\n  listTeamInvitations(): Promise<ReceivedTeamInvitation[]>,\n  /**\n   * Lists all pending team invitations sent to any of the current user's verified email addresses.\n   *\n   * React hook version of `listTeamInvitations()`. Automatically re-renders when invitations change.\n   */\n  useTeamInvitations(): ReceivedTeamInvitation[], // THIS_LINE_PLATFORM react-like\n\n  getActiveSessions(): Promise<ActiveSession[]>,\n  revokeSession(sessionId: string): Promise<void>,\n  getTeamProfile(team: Team): Promise<EditableTeamMemberProfile>,\n  useTeamProfile(team: Team): EditableTeamMemberProfile, // THIS_LINE_PLATFORM react-like\n\n  createApiKey(options: ApiKeyCreationOptions<\"user\">): Promise<UserApiKeyFirstView>,\n\n  useOAuthProviders(): OAuthProvider[], // THIS_LINE_PLATFORM react-like\n  listOAuthProviders(): Promise<OAuthProvider[]>,\n\n  useOAuthProvider(id: string): OAuthProvider | null, // THIS_LINE_PLATFORM react-like\n  getOAuthProvider(id: string): Promise<OAuthProvider | null>,\n\n  registerPasskey(options?: { hostname?: string }): Promise<Result<undefined, KnownErrors[\"PasskeyRegistrationFailed\"] | KnownErrors[\"PasskeyWebAuthnError\"]>>,\n}\n& AsyncStoreProperty<\"apiKeys\", [], UserApiKey[], true>\n& AsyncStoreProperty<\"team\", [id: string], Team | null, false>\n& AsyncStoreProperty<\"teams\", [], Team[], true>\n& AsyncStoreProperty<\"teamInvitations\", [], ReceivedTeamInvitation[], true>\n& AsyncStoreProperty<\"permission\", [scope: Team, permissionId: string, options?: { recursive?: boolean }], TeamPermission | null, false>\n& AsyncStoreProperty<\"permissions\", [scope: Team, options?: { recursive?: boolean }], TeamPermission[], true>;\n\nexport type InternalUserExtra =\n  & {\n    createProject(newProject: AdminProjectCreateOptions): Promise<AdminOwnedProject>,\n    transferProject(projectIdToTransfer: string, newTeamId: string): Promise<void>,\n  }\n  & AsyncStoreProperty<\"ownedProjects\", [], AdminOwnedProject[], true>\n\nexport type User = BaseUser;\n\nexport type CurrentUser = BaseUser & Auth & UserExtra & Customer;\n\nexport type CurrentInternalUser = CurrentUser & InternalUserExtra;\n\nexport type ProjectCurrentUser<ProjectId> = ProjectId extends \"internal\" ? CurrentInternalUser : CurrentUser;\n\nexport type TokenPartialUser = Pick<\n  User,\n  | \"id\"\n  | \"displayName\"\n  | \"primaryEmail\"\n  | \"primaryEmailVerified\"\n  | \"isAnonymous\"\n  | \"isRestricted\"\n  | \"restrictedReason\"\n>\n\nexport type SyncedPartialUser = TokenPartialUser & Pick<\n  User,\n  | \"id\"\n  | \"displayName\"\n  | \"primaryEmail\"\n  | \"primaryEmailVerified\"\n  | \"profileImageUrl\"\n  | \"signedUpAt\"\n  | \"clientMetadata\"\n  | \"clientReadOnlyMetadata\"\n  | \"isAnonymous\"\n  | \"hasPassword\"\n  | \"isRestricted\"\n  | \"restrictedReason\"\n>;\n\n\nexport type ActiveSession = {\n  id: string,\n  userId: string,\n  createdAt: Date,\n  isImpersonation: boolean,\n  lastUsedAt: Date | undefined,\n  isCurrentSession: boolean,\n  geoInfo?: GeoInfo,\n};\n\nexport type UserUpdateOptions = {\n  displayName?: string | null,\n  clientMetadata?: ReadonlyJson,\n  selectedTeamId?: string | null,\n  totpMultiFactorSecret?: Uint8Array | null,\n  profileImageUrl?: string | null,\n  otpAuthEnabled?: boolean,\n  passkeyAuthEnabled?: boolean,\n  primaryEmail?: string | null,\n}\nexport function userUpdateOptionsToCrud(options: UserUpdateOptions): CurrentUserCrud[\"Client\"][\"Update\"] {\n  return {\n    display_name: options.displayName,\n    client_metadata: options.clientMetadata,\n    selected_team_id: options.selectedTeamId,\n    totp_secret_base64: options.totpMultiFactorSecret != null ? encodeBase64(options.totpMultiFactorSecret) : options.totpMultiFactorSecret,\n    profile_image_url: options.profileImageUrl,\n    otp_auth_enabled: options.otpAuthEnabled,\n    passkey_auth_enabled: options.passkeyAuthEnabled,\n    primary_email: options.primaryEmail,\n  };\n}\n\n\nexport type ServerBaseUser = {\n  setPrimaryEmail(email: string | null, options?: { verified?: boolean | undefined }): Promise<void>,\n\n  readonly lastActiveAt: Date,\n\n  readonly serverMetadata: any,\n  setServerMetadata(metadata: any): Promise<void>,\n  setClientReadOnlyMetadata(metadata: any): Promise<void>,\n\n  /** Whether the user is restricted by an administrator. Can be set manually or by sign-up rules. */\n  readonly restrictedByAdmin: boolean,\n  /** Public reason shown to the user explaining why they are restricted. Optional. */\n  readonly restrictedByAdminReason: string | null,\n  /** Private details about the restriction (e.g., which sign-up rule triggered). Only visible to server access and above. */\n  readonly restrictedByAdminPrivateDetails: string | null,\n\n  createTeam(data: Omit<ServerTeamCreateOptions, \"creatorUserId\">): Promise<ServerTeam>,\n\n  useContactChannels(): ServerContactChannel[], // THIS_LINE_PLATFORM react-like\n  listContactChannels(): Promise<ServerContactChannel[]>,\n  createContactChannel(data: ServerContactChannelCreateOptions): Promise<ServerContactChannel>,\n\n  update(user: ServerUserUpdateOptions): Promise<void>,\n\n  grantPermission(scope: Team, permissionId: string): Promise<void>,\n  grantPermission(permissionId: string): Promise<void>,\n\n  revokePermission(scope: Team, permissionId: string): Promise<void>,\n  revokePermission(permissionId: string): Promise<void>,\n\n  getPermission(scope: Team, permissionId: string): Promise<TeamPermission | null>,\n  getPermission(permissionId: string): Promise<TeamPermission | null>,\n\n  hasPermission(scope: Team, permissionId: string): Promise<boolean>,\n  hasPermission(permissionId: string): Promise<boolean>,\n\n  listPermissions(scope: Team, options?: { recursive?: boolean }): Promise<TeamPermission[]>,\n  listPermissions(options?: { recursive?: boolean }): Promise<TeamPermission[]>,\n\n  // IF_PLATFORM react-like\n  usePermissions(scope: Team, options?: { recursive?: boolean }): TeamPermission[],\n  usePermissions(options?: { recursive?: boolean }): TeamPermission[],\n\n  usePermission(scope: Team, permissionId: string): TeamPermission | null,\n  usePermission(permissionId: string): TeamPermission | null,\n  // END_PLATFORM\n\n  useOAuthProviders(): ServerOAuthProvider[], // THIS_LINE_PLATFORM react-like\n  listOAuthProviders(): Promise<ServerOAuthProvider[]>,\n\n  useOAuthProvider(id: string): ServerOAuthProvider | null, // THIS_LINE_PLATFORM react-like\n  getOAuthProvider(id: string): Promise<ServerOAuthProvider | null>,\n\n  /**\n   * Creates a new session object with a refresh token for this user. Can be used to impersonate them.\n   */\n  createSession(options?: { expiresInMillis?: number, isImpersonation?: boolean }): Promise<{\n    getTokens(): Promise<{ accessToken: string | null, refreshToken: string | null }>,\n  }>,\n}\n& AsyncStoreProperty<\"team\", [id: string], ServerTeam | null, false>\n& AsyncStoreProperty<\"teams\", [], ServerTeam[], true>\n& AsyncStoreProperty<\"permission\", [scope: Team, permissionId: string, options?: { direct?: boolean }], AdminTeamPermission | null, false>\n& AsyncStoreProperty<\"permissions\", [scope: Team, options?: { direct?: boolean }], AdminTeamPermission[], true>;\n\n/**\n * A user including sensitive fields that should only be used on the server, never sent to the client\n * (such as sensitive information and serverMetadata).\n */\nexport type ServerUser = ServerBaseUser & BaseUser & UserExtra & Customer<true>;\n\nexport type CurrentServerUser = Auth & ServerUser;\n\nexport type CurrentInternalServerUser = CurrentServerUser & InternalUserExtra;\n\nexport type ProjectCurrentServerUser<ProjectId> = ProjectId extends \"internal\" ? CurrentInternalServerUser : CurrentServerUser;\n\nexport type SyncedPartialServerUser = SyncedPartialUser & Pick<\n  ServerUser,\n  | \"serverMetadata\"\n>;\n\nexport type ServerUserUpdateOptions = {\n  primaryEmail?: string | null,\n  primaryEmailVerified?: boolean,\n  primaryEmailAuthEnabled?: boolean,\n  clientReadOnlyMetadata?: ReadonlyJson,\n  serverMetadata?: ReadonlyJson,\n  password?: string,\n  restrictedByAdmin?: boolean,\n  restrictedByAdminReason?: string | null,\n  restrictedByAdminPrivateDetails?: string | null,\n} & UserUpdateOptions;\nexport function serverUserUpdateOptionsToCrud(options: ServerUserUpdateOptions): CurrentUserCrud[\"Server\"][\"Update\"] {\n  // Base update options\n  const baseUpdate: CurrentUserCrud[\"Server\"][\"Update\"] = {\n    display_name: options.displayName,\n    primary_email: options.primaryEmail,\n    client_metadata: options.clientMetadata,\n    client_read_only_metadata: options.clientReadOnlyMetadata,\n    server_metadata: options.serverMetadata,\n    selected_team_id: options.selectedTeamId,\n    primary_email_auth_enabled: options.primaryEmailAuthEnabled,\n    primary_email_verified: options.primaryEmailVerified,\n    password: options.password,\n    profile_image_url: options.profileImageUrl,\n    totp_secret_base64: options.totpMultiFactorSecret != null ? encodeBase64(options.totpMultiFactorSecret) : options.totpMultiFactorSecret,\n  };\n  // Add admin restriction fields (may not be in generated types yet but will be at runtime)\n  return {\n    ...baseUpdate,\n    restricted_by_admin: options.restrictedByAdmin,\n    restricted_by_admin_reason: options.restrictedByAdminReason,\n    restricted_by_admin_private_details: options.restrictedByAdminPrivateDetails,\n  } as CurrentUserCrud[\"Server\"][\"Update\"];\n}\n\n\nexport type ServerUserCreateOptions = {\n  primaryEmail?: string | null,\n  primaryEmailAuthEnabled?: boolean,\n  password?: string,\n  otpAuthEnabled?: boolean,\n  displayName?: string,\n  primaryEmailVerified?: boolean,\n  clientMetadata?: any,\n  clientReadOnlyMetadata?: any,\n  serverMetadata?: any,\n}\nexport function serverUserCreateOptionsToCrud(options: ServerUserCreateOptions): UsersCrud[\"Server\"][\"Create\"] {\n  return {\n    primary_email: options.primaryEmail,\n    password: options.password,\n    otp_auth_enabled: options.otpAuthEnabled,\n    primary_email_auth_enabled: options.primaryEmailAuthEnabled,\n    display_name: options.displayName,\n    primary_email_verified: options.primaryEmailVerified,\n    client_metadata: options.clientMetadata,\n    client_read_only_metadata: options.clientReadOnlyMetadata,\n    server_metadata: options.serverMetadata,\n  };\n}\n"
  }
];

export const BUNDLED_DASHBOARD_UI_TYPES: string = "import * as react_jsx_runtime from 'react/jsx-runtime';\nimport * as class_variance_authority_types from 'class-variance-authority/types';\nimport { VariantProps } from 'class-variance-authority';\nimport * as React$1 from 'react';\nimport React__default from 'react';\nimport { Card } from '@stackframe/stack-ui';\nimport * as RechartsPrimitive from 'recharts';\nimport * as recharts_types_util_payload_getUniqPayload from 'recharts/types/util/payload/getUniqPayload';\nimport * as recharts_types_component_Tooltip from 'recharts/types/component/Tooltip';\nimport * as recharts_types_util_types from 'recharts/types/util/types';\nimport * as recharts_types_component_DefaultTooltipContent from 'recharts/types/component/DefaultTooltipContent';\n\ntype DesignAlertVariant = \"default\" | \"success\" | \"error\" | \"warning\" | \"info\";\ntype DesignAlertProps = React.HTMLAttributes<HTMLDivElement> & {\n    variant?: DesignAlertVariant;\n    title?: React.ReactNode;\n    description?: React.ReactNode;\n    glassmorphic?: boolean;\n};\ndeclare function DesignAlert({ variant, title, description, glassmorphic, className, children, ...props }: DesignAlertProps): react_jsx_runtime.JSX.Element;\n\ntype DesignBadgeColor = \"blue\" | \"cyan\" | \"purple\" | \"green\" | \"orange\" | \"red\";\ntype DesignBadgeSize = \"sm\" | \"md\";\n/** At least one of showLabel or showIcon must be true. */\ntype DesignBadgeContentMode = \"both\" | \"text\" | \"icon\";\ntype DesignBadgeProps = {\n    label: string;\n    color: DesignBadgeColor;\n    icon?: React.ElementType;\n    size?: DesignBadgeSize;\n    /** What to display: \"both\" (default), \"text\" (label only), or \"icon\" (icon only; requires icon prop). */\n    contentMode?: DesignBadgeContentMode;\n};\ndeclare function DesignBadge({ label, color, icon, size, contentMode, }: DesignBadgeProps): react_jsx_runtime.JSX.Element;\n\ndeclare const designButtonVariants: (props?: ({\n    variant?: \"default\" | \"link\" | \"destructive\" | \"outline\" | \"secondary\" | \"ghost\" | \"plain\" | null | undefined;\n    size?: \"default\" | \"icon\" | \"sm\" | \"lg\" | null | undefined;\n} & class_variance_authority_types.ClassProp) | undefined) => string;\ntype DesignOriginalButtonProps = {\n    asChild?: boolean;\n} & React__default.ButtonHTMLAttributes<HTMLButtonElement> & VariantProps<typeof designButtonVariants>;\ntype DesignButtonProps = {\n    onClick?: (e: React__default.MouseEvent<HTMLButtonElement>) => void | Promise<void>;\n    loading?: boolean;\n    loadingStyle?: \"spinner\" | \"disabled\";\n} & DesignOriginalButtonProps;\ndeclare const DesignButton: React__default.FC<{\n    onClick?: ((e: React__default.MouseEvent<HTMLButtonElement>) => void | Promise<void>) | undefined;\n    loading?: boolean | undefined;\n    loadingStyle?: \"disabled\" | \"spinner\" | undefined;\n} & {\n    asChild?: boolean | undefined;\n} & React__default.ButtonHTMLAttributes<HTMLButtonElement> & VariantProps<(props?: ({\n    variant?: \"default\" | \"link\" | \"destructive\" | \"outline\" | \"secondary\" | \"ghost\" | \"plain\" | null | undefined;\n    size?: \"default\" | \"icon\" | \"sm\" | \"lg\" | null | undefined;\n} & class_variance_authority_types.ClassProp) | undefined) => string> & {\n    ref?: React__default.Ref<HTMLButtonElement> | undefined;\n}>;\n\n/**\n * Returns `true` when the calling component is rendered inside a DesignCard.\n * Useful for deriving a glassmorphic default.\n */\ndeclare function useInsideDesignCard(): boolean;\n/**\n * Resolve the effective glassmorphic value.\n * - If the caller passed an explicit boolean  honour it.\n * - Otherwise  fall back to whether we're inside a DesignCard.\n */\ndeclare function useGlassmorphicDefault(explicit: boolean | undefined): boolean;\ntype DesignCardGradient = \"blue\" | \"cyan\" | \"purple\" | \"green\" | \"orange\" | \"default\";\ntype DesignCardBaseProps = {\n    glassmorphic?: boolean;\n    gradient?: DesignCardGradient;\n    contentClassName?: string;\n} & Omit<React__default.ComponentProps<typeof Card>, \"title\">;\ntype WithTitleProps = {\n    title: React__default.ReactNode;\n    subtitle?: React__default.ReactNode;\n    icon: React__default.ElementType;\n    actions?: React__default.ReactNode;\n};\ntype WithoutTitleProps = {\n    title?: never;\n    subtitle?: never;\n    icon?: never;\n    actions?: never;\n};\ntype DesignCardProps = DesignCardBaseProps & (WithTitleProps | WithoutTitleProps);\ndeclare function DesignCard({ title, subtitle, icon: Icon, actions, glassmorphic: glassmorphicProp, gradient, children, className, contentClassName, ...props }: DesignCardProps): react_jsx_runtime.JSX.Element;\ntype DesignCardTintProps = {\n    gradient: DesignCardGradient;\n} & React__default.ComponentProps<\"div\">;\ndeclare function DesignCardTint({ gradient, className, children, ...props }: DesignCardTintProps): react_jsx_runtime.JSX.Element;\n\ntype CursorBlastEffectProps = {\n    /** Lifetime of each blast animation in ms. Default: 720 */\n    blastLifetimeMs?: number;\n    /** Maximum number of concurrent active blasts. Default: 18 */\n    maxActiveBlasts?: number;\n    /** Minimum rapid clicks in the time window to trigger a blast. Default: 3 */\n    rageClickThreshold?: number;\n    /** Time window (ms) for counting rage clicks. Default: 600 */\n    rageClickWindowMs?: number;\n    /** Max distance (px) between clicks to count as same-spot rage clicking. Default: 60 */\n    rageClickRadiusPx?: number;\n    /**\n     * When provided, the blast effect is scoped to this container element.\n     * Clicks are only detected within the container and blasts are positioned\n     * relative to the container rather than the viewport.\n     */\n    containerRef?: React.RefObject<HTMLElement | null>;\n};\ndeclare function CursorBlastEffect({ blastLifetimeMs, maxActiveBlasts, rageClickThreshold, rageClickWindowMs, rageClickRadiusPx, containerRef, }?: CursorBlastEffectProps): react_jsx_runtime.JSX.Element | null;\n\ndeclare function DesignEditMode({ children }: {\n    children: React.ReactNode;\n}): react_jsx_runtime.JSX.Element;\ndeclare function useDesignEditMode(): boolean;\n\ntype DesignInputProps = {\n    prefixItem?: React__default.ReactNode;\n    leadingIcon?: React__default.ReactNode;\n    size?: \"sm\" | \"md\" | \"lg\";\n} & Omit<React__default.InputHTMLAttributes<HTMLInputElement>, \"size\">;\ndeclare const DesignInput: React__default.FC<{\n    prefixItem?: React__default.ReactNode;\n    leadingIcon?: React__default.ReactNode;\n    size?: \"sm\" | \"md\" | \"lg\" | undefined;\n} & Omit<React__default.InputHTMLAttributes<HTMLInputElement>, \"size\"> & {\n    ref?: React__default.Ref<HTMLInputElement> | undefined;\n}>;\n\ntype DesignPillToggleSize = \"sm\" | \"md\" | \"lg\";\ntype DesignPillToggleGradient = \"blue\" | \"cyan\" | \"purple\" | \"green\" | \"orange\" | \"default\";\ntype DesignPillToggleOption = {\n    id: string;\n    label: string;\n    icon?: React.ElementType;\n};\ntype DesignPillToggleProps = {\n    options: DesignPillToggleOption[];\n    selected: string;\n    onSelect: (id: string) => void | Promise<void>;\n    size?: DesignPillToggleSize;\n    glassmorphic?: boolean;\n    gradient?: DesignPillToggleGradient;\n    /** When false, hides labels and shows a tooltip on hover instead. Defaults to true. */\n    showLabels?: boolean;\n    className?: string;\n};\ndeclare function DesignPillToggle({ options, selected, onSelect, size, glassmorphic: glassmorphicProp, gradient, showLabels, className, }: DesignPillToggleProps): react_jsx_runtime.JSX.Element;\n\ntype DesignSeparatorProps = {\n    orientation?: \"horizontal\" | \"vertical\";\n} & React.HTMLAttributes<HTMLDivElement>;\ndeclare function DesignSeparator({ orientation, className, ...props }: DesignSeparatorProps): react_jsx_runtime.JSX.Element;\n\ntype DesignSkeletonProps = React.HTMLAttributes<HTMLDivElement>;\ndeclare function DesignSkeleton({ className, ...props }: DesignSkeletonProps): react_jsx_runtime.JSX.Element;\n\ndeclare const DesignTable: React__default.FC<React__default.HTMLAttributes<HTMLTableElement> & {\n    ref?: React__default.Ref<HTMLTableElement> | undefined;\n}>;\ndeclare const DesignTableHeader: React__default.FC<React__default.HTMLAttributes<HTMLTableSectionElement> & {\n    ref?: React__default.Ref<HTMLTableSectionElement> | undefined;\n}>;\ndeclare const DesignTableBody: React__default.FC<React__default.HTMLAttributes<HTMLTableSectionElement> & {\n    ref?: React__default.Ref<HTMLTableSectionElement> | undefined;\n}>;\ndeclare const DesignTableRow: React__default.FC<React__default.HTMLAttributes<HTMLTableRowElement> & {\n    ref?: React__default.Ref<HTMLTableRowElement> | undefined;\n}>;\ndeclare const DesignTableHead: React__default.FC<React__default.ThHTMLAttributes<HTMLTableCellElement> & {\n    ref?: React__default.Ref<HTMLTableCellElement> | undefined;\n}>;\ndeclare const DesignTableCell: React__default.FC<React__default.TdHTMLAttributes<HTMLTableCellElement> & {\n    ref?: React__default.Ref<HTMLTableCellElement> | undefined;\n}>;\n\ntype DesignTabsSize = \"sm\" | \"md\";\ntype DesignTabsGradient = \"blue\" | \"cyan\" | \"purple\" | \"green\" | \"orange\" | \"default\";\ntype DesignCategoryTabItem = {\n    id: string;\n    label: string;\n    count?: number;\n    badgeCount?: number;\n};\ntype DesignCategoryTabsProps = Omit<React.ComponentProps<\"div\">, \"onSelect\"> & {\n    categories: DesignCategoryTabItem[];\n    selectedCategory: string;\n    onSelect: (id: string) => void | Promise<void>;\n    showBadge?: boolean;\n    size?: DesignTabsSize;\n    glassmorphic?: boolean;\n    gradient?: DesignTabsGradient;\n};\ndeclare function DesignCategoryTabs({ categories, selectedCategory, onSelect, showBadge, size, glassmorphic: glassmorphicProp, gradient, className, ...props }: DesignCategoryTabsProps): react_jsx_runtime.JSX.Element;\n\ntype DesignChartColorEntry = {\n    light: string;\n    dark: string;\n};\n/**\n * Design-system-consistent chart colors that work in light and dark mode.\n * Maps to the gradient system used across the dashboard design components.\n */\ndeclare const DESIGN_CHART_COLORS: readonly DesignChartColorEntry[];\ntype DesignChartColorName = \"blue\" | \"cyan\" | \"purple\" | \"green\" | \"orange\" | \"red\";\n/**\n * Get a chart color by index (wraps around) or by name.\n */\ndeclare function getDesignChartColor(indexOrName: number | DesignChartColorName, mode?: \"light\" | \"dark\"): string;\n/**\n * Recharts-compatible grid/axis styling constants that match the design system.\n */\ndeclare const DESIGN_CHART_GRID_COLOR = \"hsl(0 0% 50% / 0.12)\";\ndeclare const DESIGN_CHART_AXIS_TICK_STYLE: {\n    readonly fill: \"hsl(0 0% 50% / 0.5)\";\n    readonly fontSize: 11;\n};\n\ndeclare const THEMES: {\n    readonly light: \"\";\n    readonly dark: \".dark\";\n};\ntype DesignChartConfig = {\n    [k in string]: {\n        label?: React$1.ReactNode;\n        icon?: React$1.ComponentType;\n    } & ({\n        color?: string;\n        theme?: never;\n    } | {\n        color?: never;\n        theme: Record<keyof typeof THEMES, string>;\n    });\n};\ntype ChartContextProps = {\n    config: DesignChartConfig;\n};\ndeclare function useDesignChart(): ChartContextProps;\ndeclare function DesignChartStyle({ id, config }: {\n    id: string;\n    config: DesignChartConfig;\n}): react_jsx_runtime.JSX.Element | null;\ndeclare const DesignChartContainer: React$1.ForwardRefExoticComponent<Omit<React$1.ClassAttributes<HTMLDivElement> & React$1.HTMLAttributes<HTMLDivElement> & {\n    maxHeight?: number | undefined;\n    config: DesignChartConfig;\n    children: React$1.ComponentProps<typeof RechartsPrimitive.ResponsiveContainer>[\"children\"];\n}, \"ref\"> & React$1.RefAttributes<HTMLDivElement>>;\n/**\n * Helper to extract item config from a Recharts payload object.\n */\ndeclare function getPayloadConfigFromPayload(config: DesignChartConfig, payload: unknown, key: string): ({\n    label?: React$1.ReactNode;\n    icon?: React$1.ComponentType<{}> | undefined;\n} & ({\n    color?: string | undefined;\n    theme?: undefined;\n} | {\n    color?: undefined;\n    theme: Record<\"light\" | \"dark\", string>;\n})) | undefined;\n\ndeclare const DesignChartTooltip: typeof RechartsPrimitive.Tooltip;\ndeclare const DesignChartTooltipContent: React$1.ForwardRefExoticComponent<Omit<RechartsPrimitive.DefaultTooltipContentProps<recharts_types_component_DefaultTooltipContent.ValueType, recharts_types_component_DefaultTooltipContent.NameType> & {\n    accessibilityLayer?: boolean | undefined;\n    active?: boolean | undefined;\n    includeHidden?: boolean | undefined;\n    allowEscapeViewBox?: recharts_types_util_types.AllowInDimension | undefined;\n    animationDuration?: number | undefined;\n    animationEasing?: recharts_types_util_types.AnimationTiming | undefined;\n    content?: recharts_types_component_Tooltip.ContentType<recharts_types_component_DefaultTooltipContent.ValueType, recharts_types_component_DefaultTooltipContent.NameType> | undefined;\n    coordinate?: Partial<recharts_types_util_types.Coordinate> | undefined;\n    cursor?: boolean | React$1.SVGProps<SVGElement> | React$1.ReactElement<any, string | React$1.JSXElementConstructor<any>> | undefined;\n    filterNull?: boolean | undefined;\n    defaultIndex?: number | undefined;\n    isAnimationActive?: boolean | undefined;\n    offset?: number | undefined;\n    payloadUniqBy?: recharts_types_util_payload_getUniqPayload.UniqueOption<recharts_types_component_DefaultTooltipContent.Payload<recharts_types_component_DefaultTooltipContent.ValueType, recharts_types_component_DefaultTooltipContent.NameType>> | undefined;\n    position?: Partial<recharts_types_util_types.Coordinate> | undefined;\n    reverseDirection?: recharts_types_util_types.AllowInDimension | undefined;\n    shared?: boolean | undefined;\n    trigger?: \"click\" | \"hover\" | undefined;\n    useTranslate3d?: boolean | undefined;\n    viewBox?: recharts_types_util_types.CartesianViewBox | undefined;\n    wrapperStyle?: React$1.CSSProperties | undefined;\n} & React$1.ClassAttributes<HTMLDivElement> & React$1.HTMLAttributes<HTMLDivElement> & {\n    hideLabel?: boolean | undefined;\n    hideIndicator?: boolean | undefined;\n    indicator?: \"line\" | \"dashed\" | \"dot\" | undefined;\n    nameKey?: string | undefined;\n    labelKey?: string | undefined;\n}, \"ref\"> & React$1.RefAttributes<HTMLDivElement>>;\n\ndeclare const DesignChartLegend: typeof RechartsPrimitive.Legend;\ndeclare const DesignChartLegendContent: React$1.ForwardRefExoticComponent<Omit<React$1.ClassAttributes<HTMLDivElement> & React$1.HTMLAttributes<HTMLDivElement> & Pick<RechartsPrimitive.LegendProps, \"payload\" | \"verticalAlign\"> & {\n    hideIcon?: boolean | undefined;\n    nameKey?: string | undefined;\n}, \"ref\"> & React$1.RefAttributes<HTMLDivElement>>;\n\ntype DesignChartCardGradient = \"blue\" | \"cyan\" | \"purple\" | \"green\" | \"orange\" | \"default\";\ntype DesignChartCardProps = {\n    gradient?: DesignChartCardGradient;\n} & React__default.ComponentProps<\"div\">;\ndeclare function DesignChartCard({ gradient, className, children, ...props }: DesignChartCardProps): react_jsx_runtime.JSX.Element;\n\ntype DesignMetricCardGradient = \"blue\" | \"cyan\" | \"purple\" | \"green\" | \"orange\" | \"default\";\ntype DesignMetricCardTrend = {\n    value: number;\n    direction: \"up\" | \"down\";\n    label?: string;\n};\ntype DesignMetricCardProps = {\n    label: string;\n    value: string | number;\n    description?: string;\n    trend?: DesignMetricCardTrend;\n    icon?: React__default.ElementType;\n    gradient?: DesignMetricCardGradient;\n    className?: string;\n};\ndeclare function DesignMetricCard({ label, value, description, trend, icon: Icon, gradient, className, }: DesignMetricCardProps): react_jsx_runtime.JSX.Element;\n\ntype DesignProgressBarGradient = \"blue\" | \"cyan\" | \"purple\" | \"green\" | \"orange\" | \"default\";\ntype DesignProgressBarProps = {\n    value: number;\n    max?: number;\n    gradient?: DesignProgressBarGradient;\n    label?: string;\n    showPercentage?: boolean;\n    size?: \"sm\" | \"md\" | \"lg\";\n    className?: string;\n};\ndeclare function DesignProgressBar({ value, max, gradient, label, showPercentage, size, className, }: DesignProgressBarProps): react_jsx_runtime.JSX.Element;\n\ntype DesignEmptyStateProps = {\n    icon?: React__default.ElementType;\n    title?: string;\n    description?: string;\n    children?: React__default.ReactNode;\n    className?: string;\n};\ndeclare function DesignEmptyState({ icon: Icon, title, description, children, className, }: DesignEmptyStateProps): react_jsx_runtime.JSX.Element;\n\nexport { CursorBlastEffect, type CursorBlastEffectProps, DESIGN_CHART_AXIS_TICK_STYLE, DESIGN_CHART_COLORS, DESIGN_CHART_GRID_COLOR, DesignAlert, type DesignAlertProps, DesignBadge, type DesignBadgeColor, type DesignBadgeContentMode, type DesignBadgeProps, type DesignBadgeSize, DesignButton, type DesignButtonProps, DesignCard, type DesignCardProps, DesignCardTint, type DesignCardTintProps, type DesignCategoryTabItem, DesignCategoryTabs, type DesignCategoryTabsProps, DesignChartCard, type DesignChartCardProps, type DesignChartColorEntry, type DesignChartColorName, type DesignChartConfig, DesignChartContainer, DesignChartLegend, DesignChartLegendContent, DesignChartStyle, DesignChartTooltip, DesignChartTooltipContent, DesignEditMode, DesignEmptyState, type DesignEmptyStateProps, DesignInput, type DesignInputProps, DesignMetricCard, type DesignMetricCardProps, type DesignMetricCardTrend, type DesignOriginalButtonProps, DesignPillToggle, type DesignPillToggleOption, type DesignPillToggleProps, DesignProgressBar, type DesignProgressBarProps, DesignSeparator, type DesignSeparatorProps, DesignSkeleton, type DesignSkeletonProps, DesignTable, DesignTableBody, DesignTableCell, DesignTableHead, DesignTableHeader, DesignTableRow, getDesignChartColor, getPayloadConfigFromPayload, useDesignChart, useDesignEditMode, useGlassmorphicDefault, useInsideDesignCard };\n";
